{"./LICENSE": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n    1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n    2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n    3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n    4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n    5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n    6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n    7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n    8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n    9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n    END OF TERMS AND CONDITIONS\n\n    APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n    Copyright [yyyy] [name of copyright owner]\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n----------\nThe following license is exclusively used by the template generated header files.\n\nBSD 3-Clause License\n\nCopyright (c) 2019, \"WebGPU native\" developers\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n", "./ZIG_VERSION": "0.11.0-dev.1605+abc9530a8\n", "./include/tint/tint.h": "// Copyright 2020 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_TINT_TINT_H_\n#define INCLUDE_TINT_TINT_H_\n\n// Guard for accidental includes to private headers\n#define CURRENTLY_IN_TINT_PUBLIC_HEADER\n\n// TODO(tint:88): When implementing support for an install target, all of these\n//                headers will need to be moved to include/tint/.\n\n#include \"src/tint/demangler.h\"\n#include \"src/tint/diagnostic/printer.h\"\n#include \"src/tint/inspector/inspector.h\"\n#include \"src/tint/reader/reader.h\"\n#include \"src/tint/text/unicode.h\"\n#include \"src/tint/transform/binding_remapper.h\"\n#include \"src/tint/transform/clamp_frag_depth.h\"\n#include \"src/tint/transform/first_index_offset.h\"\n#include \"src/tint/transform/manager.h\"\n#include \"src/tint/transform/multiplanar_external_texture.h\"\n#include \"src/tint/transform/renamer.h\"\n#include \"src/tint/transform/robustness.h\"\n#include \"src/tint/transform/single_entry_point.h\"\n#include \"src/tint/transform/substitute_override.h\"\n#include \"src/tint/transform/vertex_pulling.h\"\n#include \"src/tint/type/manager.h\"\n#include \"src/tint/writer/flatten_bindings.h\"\n#include \"src/tint/writer/writer.h\"\n\n#if TINT_BUILD_SPV_READER\n#include \"src/tint/reader/spirv/parser.h\"\n#endif  // TINT_BUILD_SPV_READER\n\n#if TINT_BUILD_WGSL_READER\n#include \"src/tint/reader/wgsl/parser.h\"\n#endif  // TINT_BUILD_WGSL_READER\n\n#if TINT_BUILD_SPV_WRITER\n#include \"spirv-tools/libspirv.hpp\"\n#include \"src/tint/writer/spirv/generator.h\"\n#endif  // TINT_BUILD_SPV_WRITER\n\n#if TINT_BUILD_WGSL_WRITER\n#include \"src/tint/writer/wgsl/generator.h\"\n#endif  // TINT_BUILD_WGSL_WRITER\n\n#if TINT_BUILD_MSL_WRITER\n#include \"src/tint/writer/msl/generator.h\"\n#endif  // TINT_BUILD_MSL_WRITER\n\n#if TINT_BUILD_HLSL_WRITER\n#include \"src/tint/writer/hlsl/generator.h\"\n#endif  // TINT_BUILD_HLSL_WRITER\n\n#if TINT_BUILD_GLSL_WRITER\n#include \"src/tint/writer/glsl/generator.h\"\n#endif  // TINT_BUILD_GLSL_WRITER\n\nnamespace tint {\n\n/// Initialize initializes the Tint library. Call before using the Tint API.\nvoid Initialize();\n\n/// Shutdown uninitializes the Tint library. Call after using the Tint API.\nvoid Shutdown();\n\n}  // namespace tint\n\n#undef CURRENTLY_IN_TINT_PUBLIC_HEADER\n\n#endif  // INCLUDE_TINT_TINT_H_\n", "./include/tint/override_id.h": "// Copyright 2022 The Tint Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef SRC_TINT_OVERRIDE_ID_H_\n#define SRC_TINT_OVERRIDE_ID_H_\n\n#include <stdint.h>\n#include <functional>\n\n#include \"src/tint/reflection.h\"\n\nnamespace tint {\n\n/// OverrideId is a numerical identifier for an override variable, unique per program.\nstruct OverrideId {\n    uint16_t value = 0;\n\n    /// Reflect the fields of this struct so that it can be used by tint::ForeachField()\n    TINT_REFLECT(value);\n};\n\n/// Equality operator for OverrideId\n/// @param lhs the OverrideId on the left of the '=' operator\n/// @param rhs the OverrideId on the right of the '=' operator\n/// @returns true if `lhs` is equal to `rhs`\ninline bool operator==(OverrideId lhs, OverrideId rhs) {\n    return lhs.value == rhs.value;\n}\n\n/// Less-than operator for OverrideId\n/// @param lhs the OverrideId on the left of the '<' operator\n/// @param rhs the OverrideId on the right of the '<' operator\n/// @returns true if `lhs` comes before `rhs`\ninline bool operator<(OverrideId lhs, OverrideId rhs) {\n    return lhs.value < rhs.value;\n}\n\n}  // namespace tint\n\nnamespace std {\n\n/// Custom std::hash specialization for tint::OverrideId.\ntemplate <>\nclass hash<tint::OverrideId> {\n  public:\n    /// @param id the override identifier\n    /// @return the hash of the override identifier\n    inline std::size_t operator()(tint::OverrideId id) const {\n        return std::hash<decltype(tint::OverrideId::value)>()(id.value);\n    }\n};\n\n}  // namespace std\n\n#endif  // SRC_TINT_OVERRIDE_ID_H_\n", "./include/webgpu/webgpu_cpp.h": "// Copyright 2022 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_WEBGPU_WEBGPU_CPP_H_\n#define INCLUDE_WEBGPU_WEBGPU_CPP_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#endif  // INCLUDE_WEBGPU_WEBGPU_CPP_H_\n", "./include/webgpu/webgpu_glfw.h": "// Copyright 2022 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_WEBGPU_WEBGPU_GLFW_H_\n#define INCLUDE_WEBGPU_WEBGPU_GLFW_H_\n\n#include <memory>\n\n#include \"webgpu/webgpu_cpp.h\"\n\n#if defined(WGPU_GLFW_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(WGPU_GLFW_IMPLEMENTATION)\n#define WGPU_GLFW_EXPORT __declspec(dllexport)\n#else\n#define WGPU_GLFW_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(WGPU_GLFW_IMPLEMENTATION)\n#define WGPU_GLFW_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define WGPU_GLFW_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(WGPU_GLFW_SHARED_LIBRARY)\n#define WGPU_GLFW_EXPORT\n#endif  // defined(WGPU_GLFW_SHARED_LIBRARY)\n\nstruct GLFWwindow;\n\nnamespace wgpu::glfw {\n\n// Does the necessary setup on the GLFWwindow to allow creating a wgpu::Surface with it and\n// calls `instance.CreateSurface` with the correct descriptor for this window.\n// Returns a null wgpu::Surface on failure.\nWGPU_GLFW_EXPORT wgpu::Surface CreateSurfaceForWindow(const wgpu::Instance& instance,\n                                                      GLFWwindow* window);\n\n// Use for testing only. Does everything that CreateSurfaceForWindow does except the call to\n// CreateSurface. Useful to be able to modify the descriptor for testing, or when trying to\n// avoid using the global proc table.\nWGPU_GLFW_EXPORT std::unique_ptr<wgpu::ChainedStruct> SetupWindowAndGetSurfaceDescriptor(\n    GLFWwindow* window);\n\n}  // namespace wgpu::glfw\n\n#endif  // INCLUDE_WEBGPU_WEBGPU_GLFW_H_\n", "./include/webgpu/webgpu.h": "// Copyright 2022 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_WEBGPU_WEBGPU_H_\n#define INCLUDE_WEBGPU_WEBGPU_H_\n\n#include \"dawn/webgpu.h\"\n\n#endif  // INCLUDE_WEBGPU_WEBGPU_H_\n", "./include/dawn/BUILD.gn": "# Copyright 2019 The Dawn Authors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport(\"../../scripts/dawn_overrides_with_defaults.gni\")\n\nimport(\"${dawn_root}/generator/dawn_generator.gni\")\nimport(\"${dawn_root}/scripts/dawn_component.gni\")\n\n###############################################################################\n# Dawn headers\n###############################################################################\n\ndawn_json_generator(\"headers_gen\") {\n  target = \"headers\"\n  outputs = [\n    \"include/dawn/dawn_proc_table.h\",\n    \"include/dawn/webgpu.h\",\n  ]\n}\n\nsource_set(\"headers\") {\n  all_dependent_configs = [ \":public\" ]\n  public_deps = [ \":headers_gen\" ]\n\n  sources = get_target_outputs(\":headers_gen\")\n  sources += [ \"${dawn_root}/include/dawn/dawn_wsi.h\" ]\n}\n\n###############################################################################\n# Dawn C++ headers\n###############################################################################\n\ndawn_json_generator(\"cpp_headers_gen\") {\n  target = \"cpp_headers\"\n  outputs = [\n    \"include/dawn/webgpu_cpp.h\",\n    \"include/dawn/webgpu_cpp_print.h\",\n  ]\n}\n\nsource_set(\"cpp_headers\") {\n  public_deps = [\n    \":cpp_headers_gen\",\n    \":headers\",\n  ]\n\n  sources = get_target_outputs(\":cpp_headers_gen\")\n  sources += [ \"${dawn_root}/include/dawn/EnumClassBitmasks.h\" ]\n}\n\n###############################################################################\n# Dawn public include directories\n###############################################################################\n\nconfig(\"public\") {\n  include_dirs = [\n    \"${target_gen_dir}/../../include\",\n    \"${dawn_root}/include\",\n  ]\n}\n", "./include/dawn/webgpu_cpp.h": "#ifndef WEBGPU_CPP_H_\n#define WEBGPU_CPP_H_\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/EnumClassBitmasks.h\"\n#include <cmath>\n\nnamespace wgpu {\n\n    namespace detail {\n        constexpr size_t ConstexprMax(size_t a, size_t b) {\n            return a > b ? a : b;\n        }\n    }  // namespace detail\n\n    static constexpr uint32_t kArrayLayerCountUndefined = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n    static constexpr uint32_t kCopyStrideUndefined = WGPU_COPY_STRIDE_UNDEFINED;\n    static constexpr uint32_t kLimitU32Undefined = WGPU_LIMIT_U32_UNDEFINED;\n    static constexpr uint64_t kLimitU64Undefined = WGPU_LIMIT_U64_UNDEFINED;\n    static constexpr uint32_t kMipLevelCountUndefined = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n    static constexpr uint32_t kStrideUndefined = WGPU_STRIDE_UNDEFINED;\n    static constexpr size_t kWholeMapSize = WGPU_WHOLE_MAP_SIZE;\n    static constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\n\n    enum class AdapterType : uint32_t {\n        DiscreteGPU = 0x00000000,\n        IntegratedGPU = 0x00000001,\n        CPU = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class AddressMode : uint32_t {\n        Repeat = 0x00000000,\n        MirrorRepeat = 0x00000001,\n        ClampToEdge = 0x00000002,\n    };\n\n    enum class AlphaMode : uint32_t {\n        Premultiplied = 0x00000000,\n        Unpremultiplied = 0x00000001,\n        Opaque = 0x00000002,\n    };\n\n    enum class BackendType : uint32_t {\n        Null = 0x00000000,\n        WebGPU = 0x00000001,\n        D3D11 = 0x00000002,\n        D3D12 = 0x00000003,\n        Metal = 0x00000004,\n        Vulkan = 0x00000005,\n        OpenGL = 0x00000006,\n        OpenGLES = 0x00000007,\n    };\n\n    enum class BlendFactor : uint32_t {\n        Zero = 0x00000000,\n        One = 0x00000001,\n        Src = 0x00000002,\n        OneMinusSrc = 0x00000003,\n        SrcAlpha = 0x00000004,\n        OneMinusSrcAlpha = 0x00000005,\n        Dst = 0x00000006,\n        OneMinusDst = 0x00000007,\n        DstAlpha = 0x00000008,\n        OneMinusDstAlpha = 0x00000009,\n        SrcAlphaSaturated = 0x0000000A,\n        Constant = 0x0000000B,\n        OneMinusConstant = 0x0000000C,\n    };\n\n    enum class BlendOperation : uint32_t {\n        Add = 0x00000000,\n        Subtract = 0x00000001,\n        ReverseSubtract = 0x00000002,\n        Min = 0x00000003,\n        Max = 0x00000004,\n    };\n\n    enum class BufferBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Uniform = 0x00000001,\n        Storage = 0x00000002,\n        ReadOnlyStorage = 0x00000003,\n    };\n\n    enum class BufferMapAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n        DestroyedBeforeCallback = 0x00000004,\n        UnmappedBeforeCallback = 0x00000005,\n    };\n\n    enum class BufferMapState : uint32_t {\n        Unmapped = 0x00000000,\n        Pending = 0x00000001,\n        Mapped = 0x00000002,\n    };\n\n    enum class CompareFunction : uint32_t {\n        Undefined = 0x00000000,\n        Never = 0x00000001,\n        Less = 0x00000002,\n        LessEqual = 0x00000003,\n        Greater = 0x00000004,\n        GreaterEqual = 0x00000005,\n        Equal = 0x00000006,\n        NotEqual = 0x00000007,\n        Always = 0x00000008,\n    };\n\n    enum class CompilationInfoRequestStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        DeviceLost = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class CompilationMessageType : uint32_t {\n        Error = 0x00000000,\n        Warning = 0x00000001,\n        Info = 0x00000002,\n    };\n\n    enum class ComputePassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class CreatePipelineAsyncStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        DeviceLost = 0x00000002,\n        DeviceDestroyed = 0x00000003,\n        Unknown = 0x00000004,\n    };\n\n    enum class CullMode : uint32_t {\n        None = 0x00000000,\n        Front = 0x00000001,\n        Back = 0x00000002,\n    };\n\n    enum class DeviceLostReason : uint32_t {\n        Undefined = 0x00000000,\n        Destroyed = 0x00000001,\n    };\n\n    enum class ErrorFilter : uint32_t {\n        Validation = 0x00000000,\n        OutOfMemory = 0x00000001,\n        Internal = 0x00000002,\n    };\n\n    enum class ErrorType : uint32_t {\n        NoError = 0x00000000,\n        Validation = 0x00000001,\n        OutOfMemory = 0x00000002,\n        Internal = 0x00000003,\n        Unknown = 0x00000004,\n        DeviceLost = 0x00000005,\n    };\n\n    enum class ExternalTextureRotation : uint32_t {\n        Rotate0Degrees = 0x00000000,\n        Rotate90Degrees = 0x00000001,\n        Rotate180Degrees = 0x00000002,\n        Rotate270Degrees = 0x00000003,\n    };\n\n    enum class FeatureName : uint32_t {\n        Undefined = 0x00000000,\n        DepthClipControl = 0x00000001,\n        Depth32FloatStencil8 = 0x00000002,\n        TimestampQuery = 0x00000003,\n        PipelineStatisticsQuery = 0x00000004,\n        TextureCompressionBC = 0x00000005,\n        TextureCompressionETC2 = 0x00000006,\n        TextureCompressionASTC = 0x00000007,\n        IndirectFirstInstance = 0x00000008,\n        ShaderF16 = 0x00000009,\n        RG11B10UfloatRenderable = 0x0000000A,\n        DawnShaderFloat16 = 0x000003E9,\n        DawnInternalUsages = 0x000003EA,\n        DawnMultiPlanarFormats = 0x000003EB,\n        DawnNative = 0x000003EC,\n        ChromiumExperimentalDp4a = 0x000003ED,\n        TimestampQueryInsidePasses = 0x000003EE,\n    };\n\n    enum class FilterMode : uint32_t {\n        Nearest = 0x00000000,\n        Linear = 0x00000001,\n    };\n\n    enum class FrontFace : uint32_t {\n        CCW = 0x00000000,\n        CW = 0x00000001,\n    };\n\n    enum class IndexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint16 = 0x00000001,\n        Uint32 = 0x00000002,\n    };\n\n    enum class LoadOp : uint32_t {\n        Undefined = 0x00000000,\n        Clear = 0x00000001,\n        Load = 0x00000002,\n    };\n\n    enum class LoggingType : uint32_t {\n        Verbose = 0x00000000,\n        Info = 0x00000001,\n        Warning = 0x00000002,\n        Error = 0x00000003,\n    };\n\n    enum class PipelineStatisticName : uint32_t {\n        VertexShaderInvocations = 0x00000000,\n        ClipperInvocations = 0x00000001,\n        ClipperPrimitivesOut = 0x00000002,\n        FragmentShaderInvocations = 0x00000003,\n        ComputeShaderInvocations = 0x00000004,\n    };\n\n    enum class PowerPreference : uint32_t {\n        Undefined = 0x00000000,\n        LowPower = 0x00000001,\n        HighPerformance = 0x00000002,\n    };\n\n    enum class PresentMode : uint32_t {\n        Immediate = 0x00000000,\n        Mailbox = 0x00000001,\n        Fifo = 0x00000002,\n    };\n\n    enum class PrimitiveTopology : uint32_t {\n        PointList = 0x00000000,\n        LineList = 0x00000001,\n        LineStrip = 0x00000002,\n        TriangleList = 0x00000003,\n        TriangleStrip = 0x00000004,\n    };\n\n    enum class QueryType : uint32_t {\n        Occlusion = 0x00000000,\n        PipelineStatistics = 0x00000001,\n        Timestamp = 0x00000002,\n    };\n\n    enum class QueueWorkDoneStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n        DeviceLost = 0x00000003,\n    };\n\n    enum class RenderPassTimestampLocation : uint32_t {\n        Beginning = 0x00000000,\n        End = 0x00000001,\n    };\n\n    enum class RequestAdapterStatus : uint32_t {\n        Success = 0x00000000,\n        Unavailable = 0x00000001,\n        Error = 0x00000002,\n        Unknown = 0x00000003,\n    };\n\n    enum class RequestDeviceStatus : uint32_t {\n        Success = 0x00000000,\n        Error = 0x00000001,\n        Unknown = 0x00000002,\n    };\n\n    enum class SType : uint32_t {\n        Invalid = 0x00000000,\n        SurfaceDescriptorFromMetalLayer = 0x00000001,\n        SurfaceDescriptorFromWindowsHWND = 0x00000002,\n        SurfaceDescriptorFromXlibWindow = 0x00000003,\n        SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n        ShaderModuleSPIRVDescriptor = 0x00000005,\n        ShaderModuleWGSLDescriptor = 0x00000006,\n        PrimitiveDepthClipControl = 0x00000007,\n        SurfaceDescriptorFromWaylandSurface = 0x00000008,\n        SurfaceDescriptorFromAndroidNativeWindow = 0x00000009,\n        SurfaceDescriptorFromWindowsCoreWindow = 0x0000000B,\n        ExternalTextureBindingEntry = 0x0000000C,\n        ExternalTextureBindingLayout = 0x0000000D,\n        SurfaceDescriptorFromWindowsSwapChainPanel = 0x0000000E,\n        RenderPassDescriptorMaxDrawCount = 0x0000000F,\n        DawnTextureInternalUsageDescriptor = 0x000003E8,\n        DawnTogglesDeviceDescriptor = 0x000003EA,\n        DawnEncoderInternalUsageDescriptor = 0x000003EB,\n        DawnInstanceDescriptor = 0x000003EC,\n        DawnCacheDeviceDescriptor = 0x000003ED,\n        DawnAdapterPropertiesPowerPreference = 0x000003EE,\n        DawnBufferDescriptorErrorInfoFromWireClient = 0x000003EF,\n    };\n\n    enum class SamplerBindingType : uint32_t {\n        Undefined = 0x00000000,\n        Filtering = 0x00000001,\n        NonFiltering = 0x00000002,\n        Comparison = 0x00000003,\n    };\n\n    enum class StencilOperation : uint32_t {\n        Keep = 0x00000000,\n        Zero = 0x00000001,\n        Replace = 0x00000002,\n        Invert = 0x00000003,\n        IncrementClamp = 0x00000004,\n        DecrementClamp = 0x00000005,\n        IncrementWrap = 0x00000006,\n        DecrementWrap = 0x00000007,\n    };\n\n    enum class StorageTextureAccess : uint32_t {\n        Undefined = 0x00000000,\n        WriteOnly = 0x00000001,\n    };\n\n    enum class StoreOp : uint32_t {\n        Undefined = 0x00000000,\n        Store = 0x00000001,\n        Discard = 0x00000002,\n    };\n\n    enum class TextureAspect : uint32_t {\n        All = 0x00000000,\n        StencilOnly = 0x00000001,\n        DepthOnly = 0x00000002,\n        Plane0Only = 0x00000003,\n        Plane1Only = 0x00000004,\n    };\n\n    enum class TextureComponentType : uint32_t {\n        Float = 0x00000000,\n        Sint = 0x00000001,\n        Uint = 0x00000002,\n        DepthComparison = 0x00000003,\n    };\n\n    enum class TextureDimension : uint32_t {\n        e1D = 0x00000000,\n        e2D = 0x00000001,\n        e3D = 0x00000002,\n    };\n\n    enum class TextureFormat : uint32_t {\n        Undefined = 0x00000000,\n        R8Unorm = 0x00000001,\n        R8Snorm = 0x00000002,\n        R8Uint = 0x00000003,\n        R8Sint = 0x00000004,\n        R16Uint = 0x00000005,\n        R16Sint = 0x00000006,\n        R16Float = 0x00000007,\n        RG8Unorm = 0x00000008,\n        RG8Snorm = 0x00000009,\n        RG8Uint = 0x0000000A,\n        RG8Sint = 0x0000000B,\n        R32Float = 0x0000000C,\n        R32Uint = 0x0000000D,\n        R32Sint = 0x0000000E,\n        RG16Uint = 0x0000000F,\n        RG16Sint = 0x00000010,\n        RG16Float = 0x00000011,\n        RGBA8Unorm = 0x00000012,\n        RGBA8UnormSrgb = 0x00000013,\n        RGBA8Snorm = 0x00000014,\n        RGBA8Uint = 0x00000015,\n        RGBA8Sint = 0x00000016,\n        BGRA8Unorm = 0x00000017,\n        BGRA8UnormSrgb = 0x00000018,\n        RGB10A2Unorm = 0x00000019,\n        RG11B10Ufloat = 0x0000001A,\n        RGB9E5Ufloat = 0x0000001B,\n        RG32Float = 0x0000001C,\n        RG32Uint = 0x0000001D,\n        RG32Sint = 0x0000001E,\n        RGBA16Uint = 0x0000001F,\n        RGBA16Sint = 0x00000020,\n        RGBA16Float = 0x00000021,\n        RGBA32Float = 0x00000022,\n        RGBA32Uint = 0x00000023,\n        RGBA32Sint = 0x00000024,\n        Stencil8 = 0x00000025,\n        Depth16Unorm = 0x00000026,\n        Depth24Plus = 0x00000027,\n        Depth24PlusStencil8 = 0x00000028,\n        Depth32Float = 0x00000029,\n        Depth32FloatStencil8 = 0x0000002A,\n        BC1RGBAUnorm = 0x0000002B,\n        BC1RGBAUnormSrgb = 0x0000002C,\n        BC2RGBAUnorm = 0x0000002D,\n        BC2RGBAUnormSrgb = 0x0000002E,\n        BC3RGBAUnorm = 0x0000002F,\n        BC3RGBAUnormSrgb = 0x00000030,\n        BC4RUnorm = 0x00000031,\n        BC4RSnorm = 0x00000032,\n        BC5RGUnorm = 0x00000033,\n        BC5RGSnorm = 0x00000034,\n        BC6HRGBUfloat = 0x00000035,\n        BC6HRGBFloat = 0x00000036,\n        BC7RGBAUnorm = 0x00000037,\n        BC7RGBAUnormSrgb = 0x00000038,\n        ETC2RGB8Unorm = 0x00000039,\n        ETC2RGB8UnormSrgb = 0x0000003A,\n        ETC2RGB8A1Unorm = 0x0000003B,\n        ETC2RGB8A1UnormSrgb = 0x0000003C,\n        ETC2RGBA8Unorm = 0x0000003D,\n        ETC2RGBA8UnormSrgb = 0x0000003E,\n        EACR11Unorm = 0x0000003F,\n        EACR11Snorm = 0x00000040,\n        EACRG11Unorm = 0x00000041,\n        EACRG11Snorm = 0x00000042,\n        ASTC4x4Unorm = 0x00000043,\n        ASTC4x4UnormSrgb = 0x00000044,\n        ASTC5x4Unorm = 0x00000045,\n        ASTC5x4UnormSrgb = 0x00000046,\n        ASTC5x5Unorm = 0x00000047,\n        ASTC5x5UnormSrgb = 0x00000048,\n        ASTC6x5Unorm = 0x00000049,\n        ASTC6x5UnormSrgb = 0x0000004A,\n        ASTC6x6Unorm = 0x0000004B,\n        ASTC6x6UnormSrgb = 0x0000004C,\n        ASTC8x5Unorm = 0x0000004D,\n        ASTC8x5UnormSrgb = 0x0000004E,\n        ASTC8x6Unorm = 0x0000004F,\n        ASTC8x6UnormSrgb = 0x00000050,\n        ASTC8x8Unorm = 0x00000051,\n        ASTC8x8UnormSrgb = 0x00000052,\n        ASTC10x5Unorm = 0x00000053,\n        ASTC10x5UnormSrgb = 0x00000054,\n        ASTC10x6Unorm = 0x00000055,\n        ASTC10x6UnormSrgb = 0x00000056,\n        ASTC10x8Unorm = 0x00000057,\n        ASTC10x8UnormSrgb = 0x00000058,\n        ASTC10x10Unorm = 0x00000059,\n        ASTC10x10UnormSrgb = 0x0000005A,\n        ASTC12x10Unorm = 0x0000005B,\n        ASTC12x10UnormSrgb = 0x0000005C,\n        ASTC12x12Unorm = 0x0000005D,\n        ASTC12x12UnormSrgb = 0x0000005E,\n        R8BG8Biplanar420Unorm = 0x0000005F,\n    };\n\n    enum class TextureSampleType : uint32_t {\n        Undefined = 0x00000000,\n        Float = 0x00000001,\n        UnfilterableFloat = 0x00000002,\n        Depth = 0x00000003,\n        Sint = 0x00000004,\n        Uint = 0x00000005,\n    };\n\n    enum class TextureViewDimension : uint32_t {\n        Undefined = 0x00000000,\n        e1D = 0x00000001,\n        e2D = 0x00000002,\n        e2DArray = 0x00000003,\n        Cube = 0x00000004,\n        CubeArray = 0x00000005,\n        e3D = 0x00000006,\n    };\n\n    enum class VertexFormat : uint32_t {\n        Undefined = 0x00000000,\n        Uint8x2 = 0x00000001,\n        Uint8x4 = 0x00000002,\n        Sint8x2 = 0x00000003,\n        Sint8x4 = 0x00000004,\n        Unorm8x2 = 0x00000005,\n        Unorm8x4 = 0x00000006,\n        Snorm8x2 = 0x00000007,\n        Snorm8x4 = 0x00000008,\n        Uint16x2 = 0x00000009,\n        Uint16x4 = 0x0000000A,\n        Sint16x2 = 0x0000000B,\n        Sint16x4 = 0x0000000C,\n        Unorm16x2 = 0x0000000D,\n        Unorm16x4 = 0x0000000E,\n        Snorm16x2 = 0x0000000F,\n        Snorm16x4 = 0x00000010,\n        Float16x2 = 0x00000011,\n        Float16x4 = 0x00000012,\n        Float32 = 0x00000013,\n        Float32x2 = 0x00000014,\n        Float32x3 = 0x00000015,\n        Float32x4 = 0x00000016,\n        Uint32 = 0x00000017,\n        Uint32x2 = 0x00000018,\n        Uint32x3 = 0x00000019,\n        Uint32x4 = 0x0000001A,\n        Sint32 = 0x0000001B,\n        Sint32x2 = 0x0000001C,\n        Sint32x3 = 0x0000001D,\n        Sint32x4 = 0x0000001E,\n    };\n\n    enum class VertexStepMode : uint32_t {\n        Vertex = 0x00000000,\n        Instance = 0x00000001,\n        VertexBufferNotUsed = 0x00000002,\n    };\n\n\n    enum class BufferUsage : uint32_t {\n        None = 0x00000000,\n        MapRead = 0x00000001,\n        MapWrite = 0x00000002,\n        CopySrc = 0x00000004,\n        CopyDst = 0x00000008,\n        Index = 0x00000010,\n        Vertex = 0x00000020,\n        Uniform = 0x00000040,\n        Storage = 0x00000080,\n        Indirect = 0x00000100,\n        QueryResolve = 0x00000200,\n    };\n\n    enum class ColorWriteMask : uint32_t {\n        None = 0x00000000,\n        Red = 0x00000001,\n        Green = 0x00000002,\n        Blue = 0x00000004,\n        Alpha = 0x00000008,\n        All = 0x0000000F,\n    };\n\n    enum class MapMode : uint32_t {\n        None = 0x00000000,\n        Read = 0x00000001,\n        Write = 0x00000002,\n    };\n\n    enum class ShaderStage : uint32_t {\n        None = 0x00000000,\n        Vertex = 0x00000001,\n        Fragment = 0x00000002,\n        Compute = 0x00000004,\n    };\n\n    enum class TextureUsage : uint32_t {\n        None = 0x00000000,\n        CopySrc = 0x00000001,\n        CopyDst = 0x00000002,\n        TextureBinding = 0x00000004,\n        StorageBinding = 0x00000008,\n        RenderAttachment = 0x00000010,\n        Present = 0x00000020,\n    };\n\n\n    using BufferMapCallback = WGPUBufferMapCallback;\n    using CompilationInfoCallback = WGPUCompilationInfoCallback;\n    using CreateComputePipelineAsyncCallback = WGPUCreateComputePipelineAsyncCallback;\n    using CreateRenderPipelineAsyncCallback = WGPUCreateRenderPipelineAsyncCallback;\n    using DeviceLostCallback = WGPUDeviceLostCallback;\n    using ErrorCallback = WGPUErrorCallback;\n    using LoggingCallback = WGPULoggingCallback;\n    using Proc = WGPUProc;\n    using QueueWorkDoneCallback = WGPUQueueWorkDoneCallback;\n    using RequestAdapterCallback = WGPURequestAdapterCallback;\n    using RequestDeviceCallback = WGPURequestDeviceCallback;\n\n    class Adapter;\n    class BindGroup;\n    class BindGroupLayout;\n    class Buffer;\n    class CommandBuffer;\n    class CommandEncoder;\n    class ComputePassEncoder;\n    class ComputePipeline;\n    class Device;\n    class ExternalTexture;\n    class Instance;\n    class PipelineLayout;\n    class QuerySet;\n    class Queue;\n    class RenderBundle;\n    class RenderBundleEncoder;\n    class RenderPassEncoder;\n    class RenderPipeline;\n    class Sampler;\n    class ShaderModule;\n    class Surface;\n    class SwapChain;\n    class Texture;\n    class TextureView;\n\n    struct AdapterProperties;\n    struct BindGroupEntry;\n    struct BlendComponent;\n    struct BufferBindingLayout;\n    struct BufferDescriptor;\n    struct Color;\n    struct CommandBufferDescriptor;\n    struct CommandEncoderDescriptor;\n    struct CompilationMessage;\n    struct ComputePassTimestampWrite;\n    struct ConstantEntry;\n    struct CopyTextureForBrowserOptions;\n    struct DawnAdapterPropertiesPowerPreference;\n    struct DawnBufferDescriptorErrorInfoFromWireClient;\n    struct DawnCacheDeviceDescriptor;\n    struct DawnEncoderInternalUsageDescriptor;\n    struct DawnInstanceDescriptor;\n    struct DawnTextureInternalUsageDescriptor;\n    struct DawnTogglesDeviceDescriptor;\n    struct Extent2D;\n    struct Extent3D;\n    struct ExternalTextureBindingEntry;\n    struct ExternalTextureBindingLayout;\n    struct InstanceDescriptor;\n    struct Limits;\n    struct MultisampleState;\n    struct Origin2D;\n    struct Origin3D;\n    struct PipelineLayoutDescriptor;\n    struct PrimitiveDepthClipControl;\n    struct PrimitiveState;\n    struct QuerySetDescriptor;\n    struct QueueDescriptor;\n    struct RenderBundleDescriptor;\n    struct RenderBundleEncoderDescriptor;\n    struct RenderPassDepthStencilAttachment;\n    struct RenderPassDescriptorMaxDrawCount;\n    struct RenderPassTimestampWrite;\n    struct RequestAdapterOptions;\n    struct SamplerBindingLayout;\n    struct SamplerDescriptor;\n    struct ShaderModuleDescriptor;\n    struct ShaderModuleSPIRVDescriptor;\n    struct ShaderModuleWGSLDescriptor;\n    struct StencilFaceState;\n    struct StorageTextureBindingLayout;\n    struct SurfaceDescriptor;\n    struct SurfaceDescriptorFromAndroidNativeWindow;\n    struct SurfaceDescriptorFromCanvasHTMLSelector;\n    struct SurfaceDescriptorFromMetalLayer;\n    struct SurfaceDescriptorFromWaylandSurface;\n    struct SurfaceDescriptorFromWindowsCoreWindow;\n    struct SurfaceDescriptorFromWindowsHWND;\n    struct SurfaceDescriptorFromWindowsSwapChainPanel;\n    struct SurfaceDescriptorFromXlibWindow;\n    struct SwapChainDescriptor;\n    struct TextureBindingLayout;\n    struct TextureDataLayout;\n    struct TextureViewDescriptor;\n    struct VertexAttribute;\n    struct BindGroupDescriptor;\n    struct BindGroupLayoutEntry;\n    struct BlendState;\n    struct CompilationInfo;\n    struct ComputePassDescriptor;\n    struct DepthStencilState;\n    struct ExternalTextureDescriptor;\n    struct ImageCopyBuffer;\n    struct ImageCopyExternalTexture;\n    struct ImageCopyTexture;\n    struct ProgrammableStageDescriptor;\n    struct RenderPassColorAttachment;\n    struct RequiredLimits;\n    struct SupportedLimits;\n    struct TextureDescriptor;\n    struct VertexBufferLayout;\n    struct BindGroupLayoutDescriptor;\n    struct ColorTargetState;\n    struct ComputePipelineDescriptor;\n    struct DeviceDescriptor;\n    struct RenderPassDescriptor;\n    struct VertexState;\n    struct FragmentState;\n    struct RenderPipelineDescriptor;\n\n    template<typename Derived, typename CType>\n    class ObjectBase {\n      public:\n        ObjectBase() = default;\n        ObjectBase(CType handle): mHandle(handle) {\n            if (mHandle) Derived::WGPUReference(mHandle);\n        }\n        ~ObjectBase() {\n            if (mHandle) Derived::WGPURelease(mHandle);\n        }\n\n        ObjectBase(ObjectBase const& other)\n            : ObjectBase(other.Get()) {\n        }\n        Derived& operator=(ObjectBase const& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                if (mHandle) Derived::WGPUReference(mHandle);\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(ObjectBase&& other) {\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n        Derived& operator=(ObjectBase&& other) {\n            if (&other != this) {\n                if (mHandle) Derived::WGPURelease(mHandle);\n                mHandle = other.mHandle;\n                other.mHandle = 0;\n            }\n\n            return static_cast<Derived&>(*this);\n        }\n\n        ObjectBase(std::nullptr_t) {}\n        Derived& operator=(std::nullptr_t) {\n            if (mHandle != nullptr) {\n                Derived::WGPURelease(mHandle);\n                mHandle = nullptr;\n            }\n            return static_cast<Derived&>(*this);\n        }\n\n        bool operator==(std::nullptr_t) const {\n            return mHandle == nullptr;\n        }\n        bool operator!=(std::nullptr_t) const {\n            return mHandle != nullptr;\n        }\n\n        explicit operator bool() const {\n            return mHandle != nullptr;\n        }\n        CType Get() const {\n            return mHandle;\n        }\n        CType Release() {\n            CType result = mHandle;\n            mHandle = 0;\n            return result;\n        }\n        static Derived Acquire(CType handle) {\n            Derived result;\n            result.mHandle = handle;\n            return result;\n        }\n\n      protected:\n        CType mHandle = nullptr;\n    };\n\n\n\n    class Adapter : public ObjectBase<Adapter, WGPUAdapter> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Device CreateDevice(DeviceDescriptor const * descriptor = nullptr) const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        bool GetLimits(SupportedLimits * limits) const;\n        void GetProperties(AdapterProperties * properties) const;\n        bool HasFeature(FeatureName feature) const;\n        void RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Adapter, WGPUAdapter>;\n        static void WGPUReference(WGPUAdapter handle);\n        static void WGPURelease(WGPUAdapter handle);\n    };\n\n    class BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroup, WGPUBindGroup>;\n        static void WGPUReference(WGPUBindGroup handle);\n        static void WGPURelease(WGPUBindGroup handle);\n    };\n\n    class BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n        static void WGPUReference(WGPUBindGroupLayout handle);\n        static void WGPURelease(WGPUBindGroupLayout handle);\n    };\n\n    class Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void const * GetConstMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        BufferMapState GetMapState() const;\n        void * GetMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n        uint64_t GetSize() const;\n        BufferUsage GetUsage() const;\n        void MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Unmap() const;\n\n      private:\n        friend ObjectBase<Buffer, WGPUBuffer>;\n        static void WGPUReference(WGPUBuffer handle);\n        static void WGPURelease(WGPUBuffer handle);\n    };\n\n    class CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n        static void WGPUReference(WGPUCommandBuffer handle);\n        static void WGPURelease(WGPUCommandBuffer handle);\n    };\n\n    class CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n        RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n        void ClearBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n        void CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        void CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        void CopyTextureToTextureInternal(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n        CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n        void InjectValidationError(char const * message) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const;\n        void SetLabel(char const * label) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n        static void WGPUReference(WGPUCommandEncoder handle);\n        static void WGPURelease(WGPUCommandEncoder handle);\n    };\n\n    class ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Dispatch(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n        void DispatchIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n        void DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndPass() const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(ComputePipeline const& pipeline) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n        static void WGPUReference(WGPUComputePassEncoder handle);\n        static void WGPURelease(WGPUComputePassEncoder handle);\n    };\n\n    class ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n        static void WGPUReference(WGPUComputePipeline handle);\n        static void WGPURelease(WGPUComputePipeline handle);\n    };\n\n    class Device : public ObjectBase<Device, WGPUDevice> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n        BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n        Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n        CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n        ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n        void CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const;\n        Buffer CreateErrorBuffer(BufferDescriptor const * descriptor) const;\n        ExternalTexture CreateErrorExternalTexture() const;\n        Texture CreateErrorTexture(TextureDescriptor const * descriptor) const;\n        ExternalTexture CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const;\n        PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n        QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n        RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n        RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n        void CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const;\n        Sampler CreateSampler(SamplerDescriptor const * descriptor = nullptr) const;\n        ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n        SwapChain CreateSwapChain(Surface const& surface, SwapChainDescriptor const * descriptor) const;\n        Texture CreateTexture(TextureDescriptor const * descriptor) const;\n        void Destroy() const;\n        size_t EnumerateFeatures(FeatureName * features) const;\n        void ForceLoss(DeviceLostReason type, char const * message) const;\n        Adapter GetAdapter() const;\n        bool GetLimits(SupportedLimits * limits) const;\n        Queue GetQueue() const;\n        bool HasFeature(FeatureName feature) const;\n        void InjectError(ErrorType type, char const * message) const;\n        bool PopErrorScope(ErrorCallback callback, void * userdata) const;\n        void PushErrorScope(ErrorFilter filter) const;\n        void SetDeviceLostCallback(DeviceLostCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void SetLoggingCallback(LoggingCallback callback, void * userdata) const;\n        void SetUncapturedErrorCallback(ErrorCallback callback, void * userdata) const;\n        void Tick() const;\n        void ValidateTextureDescriptor(TextureDescriptor const * descriptor) const;\n\n      private:\n        friend ObjectBase<Device, WGPUDevice>;\n        static void WGPUReference(WGPUDevice handle);\n        static void WGPURelease(WGPUDevice handle);\n    };\n\n    class ExternalTexture : public ObjectBase<ExternalTexture, WGPUExternalTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ExternalTexture, WGPUExternalTexture>;\n        static void WGPUReference(WGPUExternalTexture handle);\n        static void WGPURelease(WGPUExternalTexture handle);\n    };\n\n    class Instance : public ObjectBase<Instance, WGPUInstance> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n        void RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const;\n\n      private:\n        friend ObjectBase<Instance, WGPUInstance>;\n        static void WGPUReference(WGPUInstance handle);\n        static void WGPURelease(WGPUInstance handle);\n    };\n\n    class PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n        static void WGPUReference(WGPUPipelineLayout handle);\n        static void WGPURelease(WGPUPipelineLayout handle);\n    };\n\n    class QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Destroy() const;\n        uint32_t GetCount() const;\n        QueryType GetType() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<QuerySet, WGPUQuerySet>;\n        static void WGPUReference(WGPUQuerySet handle);\n        static void WGPURelease(WGPUQuerySet handle);\n    };\n\n    class Queue : public ObjectBase<Queue, WGPUQueue> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void CopyExternalTextureForBrowser(ImageCopyExternalTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n        void CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n        void OnSubmittedWorkDone(uint64_t signalValue, QueueWorkDoneCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n        void Submit(uint32_t commandCount, CommandBuffer const * commands) const;\n        void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n        void WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const;\n\n      private:\n        friend ObjectBase<Queue, WGPUQueue>;\n        static void WGPUReference(WGPUQueue handle);\n        static void WGPURelease(WGPUQueue handle);\n    };\n\n    class RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<RenderBundle, WGPURenderBundle>;\n        static void WGPUReference(WGPURenderBundle handle);\n        static void WGPURelease(WGPURenderBundle handle);\n    };\n\n    class RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n\n      private:\n        friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n        static void WGPUReference(WGPURenderBundleEncoder handle);\n        static void WGPURelease(WGPURenderBundleEncoder handle);\n    };\n\n    class RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void BeginOcclusionQuery(uint32_t queryIndex) const;\n        void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n        void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n        void End() const;\n        void EndOcclusionQuery() const;\n        void EndPass() const;\n        void ExecuteBundles(uint32_t bundleCount, RenderBundle const * bundles) const;\n        void InsertDebugMarker(char const * markerLabel) const;\n        void PopDebugGroup() const;\n        void PushDebugGroup(char const * groupLabel) const;\n        void SetBindGroup(uint32_t groupIndex, BindGroup const& group, uint32_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n        void SetBlendConstant(Color const * color) const;\n        void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetLabel(char const * label) const;\n        void SetPipeline(RenderPipeline const& pipeline) const;\n        void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n        void SetStencilReference(uint32_t reference) const;\n        void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n        void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n        void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n      private:\n        friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n        static void WGPUReference(WGPURenderPassEncoder handle);\n        static void WGPURelease(WGPURenderPassEncoder handle);\n    };\n\n    class RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n        static void WGPUReference(WGPURenderPipeline handle);\n        static void WGPURelease(WGPURenderPipeline handle);\n    };\n\n    class Sampler : public ObjectBase<Sampler, WGPUSampler> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Sampler, WGPUSampler>;\n        static void WGPUReference(WGPUSampler handle);\n        static void WGPURelease(WGPUSampler handle);\n    };\n\n    class ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<ShaderModule, WGPUShaderModule>;\n        static void WGPUReference(WGPUShaderModule handle);\n        static void WGPURelease(WGPUShaderModule handle);\n    };\n\n    class Surface : public ObjectBase<Surface, WGPUSurface> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n\n      private:\n        friend ObjectBase<Surface, WGPUSurface>;\n        static void WGPUReference(WGPUSurface handle);\n        static void WGPURelease(WGPUSurface handle);\n    };\n\n    class SwapChain : public ObjectBase<SwapChain, WGPUSwapChain> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void Configure(TextureFormat format, TextureUsage allowedUsage, uint32_t width, uint32_t height) const;\n        TextureView GetCurrentTextureView() const;\n        void Present() const;\n\n      private:\n        friend ObjectBase<SwapChain, WGPUSwapChain>;\n        static void WGPUReference(WGPUSwapChain handle);\n        static void WGPURelease(WGPUSwapChain handle);\n    };\n\n    class Texture : public ObjectBase<Texture, WGPUTexture> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n        void Destroy() const;\n        uint32_t GetDepthOrArrayLayers() const;\n        TextureDimension GetDimension() const;\n        TextureFormat GetFormat() const;\n        uint32_t GetHeight() const;\n        uint32_t GetMipLevelCount() const;\n        uint32_t GetSampleCount() const;\n        TextureUsage GetUsage() const;\n        uint32_t GetWidth() const;\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<Texture, WGPUTexture>;\n        static void WGPUReference(WGPUTexture handle);\n        static void WGPURelease(WGPUTexture handle);\n    };\n\n    class TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n      public:\n        using ObjectBase::ObjectBase;\n        using ObjectBase::operator=;\n\n        void SetLabel(char const * label) const;\n\n      private:\n        friend ObjectBase<TextureView, WGPUTextureView>;\n        static void WGPUReference(WGPUTextureView handle);\n        static void WGPURelease(WGPUTextureView handle);\n    };\n\n\n    Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr);\n    Proc GetProcAddress(Device device, char const * procName);\n\n    struct ChainedStruct {\n        ChainedStruct const * nextInChain = nullptr;\n        SType sType = SType::Invalid;\n    };\n\n    struct ChainedStructOut {\n        ChainedStruct * nextInChain = nullptr;\n        SType sType = SType::Invalid;\n    };\n\n    struct AdapterProperties {\n        ChainedStructOut  * nextInChain = nullptr;\n        uint32_t vendorID;\n        char const * vendorName;\n        char const * architecture;\n        uint32_t deviceID;\n        char const * name;\n        char const * driverDescription;\n        AdapterType adapterType;\n        BackendType backendType;\n    };\n\n    struct BindGroupEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        Buffer buffer = nullptr;\n        uint64_t offset = 0;\n        uint64_t size = WGPU_WHOLE_SIZE;\n        Sampler sampler = nullptr;\n        TextureView textureView = nullptr;\n    };\n\n    struct BlendComponent {\n        BlendOperation operation = BlendOperation::Add;\n        BlendFactor srcFactor = BlendFactor::One;\n        BlendFactor dstFactor = BlendFactor::Zero;\n    };\n\n    struct BufferBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        BufferBindingType type = BufferBindingType::Undefined;\n        bool hasDynamicOffset = false;\n        uint64_t minBindingSize = 0;\n    };\n\n    struct BufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BufferUsage usage;\n        uint64_t size;\n        bool mappedAtCreation = false;\n    };\n\n    struct Color {\n        double r;\n        double g;\n        double b;\n        double a;\n    };\n\n    struct CommandBufferDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CommandEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct CompilationMessage {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * message = nullptr;\n        CompilationMessageType type;\n        uint64_t lineNum;\n        uint64_t linePos;\n        uint64_t offset;\n        uint64_t length;\n        uint64_t utf16LinePos;\n        uint64_t utf16Offset;\n        uint64_t utf16Length;\n    };\n\n    struct ComputePassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        ComputePassTimestampLocation location;\n    };\n\n    struct ConstantEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * key;\n        double value;\n    };\n\n    struct CopyTextureForBrowserOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        bool flipY = false;\n        bool needsColorSpaceConversion = false;\n        AlphaMode srcAlphaMode = AlphaMode::Unpremultiplied;\n        float const * srcTransferFunctionParameters = nullptr;\n        float const * conversionMatrix = nullptr;\n        float const * dstTransferFunctionParameters = nullptr;\n        AlphaMode dstAlphaMode = AlphaMode::Unpremultiplied;\n        bool internalUsage = false;\n    };\n\n    // Can be chained in AdapterProperties\n    struct DawnAdapterPropertiesPowerPreference : ChainedStructOut {\n        DawnAdapterPropertiesPowerPreference() {\n            sType = SType::DawnAdapterPropertiesPowerPreference;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(PowerPreference ));\n        alignas(kFirstMemberAlignment) PowerPreference powerPreference = PowerPreference::Undefined;\n    };\n\n    // Can be chained in BufferDescriptor\n    struct DawnBufferDescriptorErrorInfoFromWireClient : ChainedStruct {\n        DawnBufferDescriptorErrorInfoFromWireClient() {\n            sType = SType::DawnBufferDescriptorErrorInfoFromWireClient;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool outOfMemory = false;\n    };\n\n    // Can be chained in DeviceDescriptor\n    struct DawnCacheDeviceDescriptor : ChainedStruct {\n        DawnCacheDeviceDescriptor() {\n            sType = SType::DawnCacheDeviceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * isolationKey = \"\";\n    };\n\n    // Can be chained in CommandEncoderDescriptor\n    struct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n        DawnEncoderInternalUsageDescriptor() {\n            sType = SType::DawnEncoderInternalUsageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool useInternalUsages = false;\n    };\n\n    // Can be chained in InstanceDescriptor\n    struct DawnInstanceDescriptor : ChainedStruct {\n        DawnInstanceDescriptor() {\n            sType = SType::DawnInstanceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t additionalRuntimeSearchPathsCount = 0;\n        const char* const * additionalRuntimeSearchPaths;\n    };\n\n    // Can be chained in TextureDescriptor\n    struct DawnTextureInternalUsageDescriptor : ChainedStruct {\n        DawnTextureInternalUsageDescriptor() {\n            sType = SType::DawnTextureInternalUsageDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureUsage ));\n        alignas(kFirstMemberAlignment) TextureUsage internalUsage = TextureUsage::None;\n    };\n\n    // Can be chained in DeviceDescriptor\n    struct DawnTogglesDeviceDescriptor : ChainedStruct {\n        DawnTogglesDeviceDescriptor() {\n            sType = SType::DawnTogglesDeviceDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t forceEnabledTogglesCount = 0;\n        const char* const * forceEnabledToggles;\n        uint32_t forceDisabledTogglesCount = 0;\n        const char* const * forceDisabledToggles;\n    };\n\n    struct Extent2D {\n        uint32_t width = 0;\n        uint32_t height = 1;\n    };\n\n    struct Extent3D {\n        uint32_t width;\n        uint32_t height = 1;\n        uint32_t depthOrArrayLayers = 1;\n    };\n\n    // Can be chained in BindGroupEntry\n    struct ExternalTextureBindingEntry : ChainedStruct {\n        ExternalTextureBindingEntry() {\n            sType = SType::ExternalTextureBindingEntry;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(ExternalTexture ));\n        alignas(kFirstMemberAlignment) ExternalTexture externalTexture;\n    };\n\n    // Can be chained in BindGroupLayoutEntry\n    struct ExternalTextureBindingLayout : ChainedStruct {\n        ExternalTextureBindingLayout() {\n            sType = SType::ExternalTextureBindingLayout;\n        }\n    };\n\n    struct InstanceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n    };\n\n    struct Limits {\n        uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxBindingsPerBindGroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n        uint64_t maxBufferSize = WGPU_LIMIT_U64_UNDEFINED;\n        uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxColorAttachmentBytesPerSample = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n        uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n    };\n\n    struct MultisampleState {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t count = 1;\n        uint32_t mask = 0xFFFFFFFF;\n        bool alphaToCoverageEnabled = false;\n    };\n\n    struct Origin2D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n    };\n\n    struct Origin3D {\n        uint32_t x = 0;\n        uint32_t y = 0;\n        uint32_t z = 0;\n    };\n\n    struct PipelineLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t bindGroupLayoutCount;\n        BindGroupLayout const * bindGroupLayouts;\n    };\n\n    // Can be chained in PrimitiveState\n    struct PrimitiveDepthClipControl : ChainedStruct {\n        PrimitiveDepthClipControl() {\n            sType = SType::PrimitiveDepthClipControl;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(bool ));\n        alignas(kFirstMemberAlignment) bool unclippedDepth = false;\n    };\n\n    struct PrimitiveState {\n        ChainedStruct const * nextInChain = nullptr;\n        PrimitiveTopology topology = PrimitiveTopology::TriangleList;\n        IndexFormat stripIndexFormat = IndexFormat::Undefined;\n        FrontFace frontFace = FrontFace::CCW;\n        CullMode cullMode = CullMode::None;\n    };\n\n    struct QuerySetDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        QueryType type;\n        uint32_t count;\n        PipelineStatisticName const * pipelineStatistics;\n        uint32_t pipelineStatisticsCount = 0;\n    };\n\n    struct QueueDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    struct RenderBundleEncoderDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorFormatsCount;\n        TextureFormat const * colorFormats;\n        TextureFormat depthStencilFormat = TextureFormat::Undefined;\n        uint32_t sampleCount = 1;\n        bool depthReadOnly = false;\n        bool stencilReadOnly = false;\n    };\n\n    struct RenderPassDepthStencilAttachment {\n        TextureView view;\n        LoadOp depthLoadOp = LoadOp::Undefined;\n        StoreOp depthStoreOp = StoreOp::Undefined;\n        float clearDepth = NAN;\n        float depthClearValue = 0;\n        bool depthReadOnly = false;\n        LoadOp stencilLoadOp = LoadOp::Undefined;\n        StoreOp stencilStoreOp = StoreOp::Undefined;\n        uint32_t clearStencil = 0;\n        uint32_t stencilClearValue = 0;\n        bool stencilReadOnly = false;\n    };\n\n    // Can be chained in RenderPassDescriptor\n    struct RenderPassDescriptorMaxDrawCount : ChainedStruct {\n        RenderPassDescriptorMaxDrawCount() {\n            sType = SType::RenderPassDescriptorMaxDrawCount;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n        alignas(kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n    };\n\n    struct RenderPassTimestampWrite {\n        QuerySet querySet;\n        uint32_t queryIndex;\n        RenderPassTimestampLocation location;\n    };\n\n    struct RequestAdapterOptions {\n        ChainedStruct const * nextInChain = nullptr;\n        Surface compatibleSurface = nullptr;\n        PowerPreference powerPreference = PowerPreference::Undefined;\n        bool forceFallbackAdapter = false;\n    };\n\n    struct SamplerBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        SamplerBindingType type = SamplerBindingType::Undefined;\n    };\n\n    struct SamplerDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        AddressMode addressModeU = AddressMode::ClampToEdge;\n        AddressMode addressModeV = AddressMode::ClampToEdge;\n        AddressMode addressModeW = AddressMode::ClampToEdge;\n        FilterMode magFilter = FilterMode::Nearest;\n        FilterMode minFilter = FilterMode::Nearest;\n        FilterMode mipmapFilter = FilterMode::Nearest;\n        float lodMinClamp = 0.0f;\n        float lodMaxClamp = 1000.0f;\n        CompareFunction compare = CompareFunction::Undefined;\n        uint16_t maxAnisotropy = 1;\n    };\n\n    struct ShaderModuleDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct ShaderModuleSPIRVDescriptor : ChainedStruct {\n        ShaderModuleSPIRVDescriptor() {\n            sType = SType::ShaderModuleSPIRVDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n        alignas(kFirstMemberAlignment) uint32_t codeSize;\n        uint32_t const * code;\n    };\n\n    // Can be chained in ShaderModuleDescriptor\n    struct ShaderModuleWGSLDescriptor : ChainedStruct {\n        ShaderModuleWGSLDescriptor() {\n            sType = SType::ShaderModuleWGSLDescriptor;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * source;\n    };\n\n    struct StencilFaceState {\n        CompareFunction compare = CompareFunction::Always;\n        StencilOperation failOp = StencilOperation::Keep;\n        StencilOperation depthFailOp = StencilOperation::Keep;\n        StencilOperation passOp = StencilOperation::Keep;\n    };\n\n    struct StorageTextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        StorageTextureAccess access = StorageTextureAccess::Undefined;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n    };\n\n    struct SurfaceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromAndroidNativeWindow : ChainedStruct {\n        SurfaceDescriptorFromAndroidNativeWindow() {\n            sType = SType::SurfaceDescriptorFromAndroidNativeWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * window;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromCanvasHTMLSelector : ChainedStruct {\n        SurfaceDescriptorFromCanvasHTMLSelector() {\n            sType = SType::SurfaceDescriptorFromCanvasHTMLSelector;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(char const * ));\n        alignas(kFirstMemberAlignment) char const * selector;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromMetalLayer : ChainedStruct {\n        SurfaceDescriptorFromMetalLayer() {\n            sType = SType::SurfaceDescriptorFromMetalLayer;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * layer;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWaylandSurface : ChainedStruct {\n        SurfaceDescriptorFromWaylandSurface() {\n            sType = SType::SurfaceDescriptorFromWaylandSurface;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * display;\n        void * surface;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n        SurfaceDescriptorFromWindowsCoreWindow() {\n            sType = SType::SurfaceDescriptorFromWindowsCoreWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * coreWindow;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWindowsHWND : ChainedStruct {\n        SurfaceDescriptorFromWindowsHWND() {\n            sType = SType::SurfaceDescriptorFromWindowsHWND;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * hinstance;\n        void * hwnd;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n        SurfaceDescriptorFromWindowsSwapChainPanel() {\n            sType = SType::SurfaceDescriptorFromWindowsSwapChainPanel;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * swapChainPanel;\n    };\n\n    // Can be chained in SurfaceDescriptor\n    struct SurfaceDescriptorFromXlibWindow : ChainedStruct {\n        SurfaceDescriptorFromXlibWindow() {\n            sType = SType::SurfaceDescriptorFromXlibWindow;\n        }\n        static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n        alignas(kFirstMemberAlignment) void * display;\n        uint32_t window;\n    };\n\n    struct SwapChainDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureFormat format;\n        uint32_t width;\n        uint32_t height;\n        PresentMode presentMode;\n        uint64_t implementation = 0;\n    };\n\n    struct TextureBindingLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureSampleType sampleType = TextureSampleType::Undefined;\n        TextureViewDimension viewDimension = TextureViewDimension::Undefined;\n        bool multisampled = false;\n    };\n\n    struct TextureDataLayout {\n        ChainedStruct const * nextInChain = nullptr;\n        uint64_t offset = 0;\n        uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n        uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n    };\n\n    struct TextureViewDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureFormat format = TextureFormat::Undefined;\n        TextureViewDimension dimension = TextureViewDimension::Undefined;\n        uint32_t baseMipLevel = 0;\n        uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n        uint32_t baseArrayLayer = 0;\n        uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct VertexAttribute {\n        VertexFormat format;\n        uint64_t offset;\n        uint32_t shaderLocation;\n    };\n\n    struct BindGroupDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        BindGroupLayout layout;\n        uint32_t entryCount;\n        BindGroupEntry const * entries;\n    };\n\n    struct BindGroupLayoutEntry {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t binding;\n        ShaderStage visibility;\n        BufferBindingLayout buffer;\n        SamplerBindingLayout sampler;\n        TextureBindingLayout texture;\n        StorageTextureBindingLayout storageTexture;\n    };\n\n    struct BlendState {\n        BlendComponent color;\n        BlendComponent alpha;\n    };\n\n    struct CompilationInfo {\n        ChainedStruct const * nextInChain = nullptr;\n        uint32_t messageCount;\n        CompilationMessage const * messages;\n    };\n\n    struct ComputePassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t timestampWriteCount = 0;\n        ComputePassTimestampWrite const * timestampWrites;\n    };\n\n    struct DepthStencilState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        bool depthWriteEnabled = false;\n        CompareFunction depthCompare = CompareFunction::Always;\n        StencilFaceState stencilFront;\n        StencilFaceState stencilBack;\n        uint32_t stencilReadMask = 0xFFFFFFFF;\n        uint32_t stencilWriteMask = 0xFFFFFFFF;\n        int32_t depthBias = 0;\n        float depthBiasSlopeScale = 0.0f;\n        float depthBiasClamp = 0.0f;\n    };\n\n    struct ExternalTextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureView plane0;\n        TextureView plane1 = nullptr;\n        Origin2D visibleOrigin;\n        Extent2D visibleSize;\n        bool doYuvToRgbConversionOnly = false;\n        float const * yuvToRgbConversionMatrix = nullptr;\n        float const * srcTransferFunctionParameters;\n        float const * dstTransferFunctionParameters;\n        float const * gamutConversionMatrix;\n        bool flipY = false;\n        ExternalTextureRotation rotation = ExternalTextureRotation::Rotate0Degrees;\n    };\n\n    struct ImageCopyBuffer {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureDataLayout layout;\n        Buffer buffer;\n    };\n\n    struct ImageCopyExternalTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        ExternalTexture externalTexture;\n        Origin3D origin;\n    };\n\n    struct ImageCopyTexture {\n        ChainedStruct const * nextInChain = nullptr;\n        Texture texture;\n        uint32_t mipLevel = 0;\n        Origin3D origin;\n        TextureAspect aspect = TextureAspect::All;\n    };\n\n    struct ProgrammableStageDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n    };\n\n    struct RenderPassColorAttachment {\n        TextureView view = nullptr;\n        TextureView resolveTarget = nullptr;\n        LoadOp loadOp;\n        StoreOp storeOp;\n        Color clearColor = { NAN, NAN, NAN, NAN };\n        Color clearValue;\n    };\n\n    struct RequiredLimits {\n        ChainedStruct const * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct SupportedLimits {\n        ChainedStructOut  * nextInChain = nullptr;\n        Limits limits;\n    };\n\n    struct TextureDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        TextureUsage usage;\n        TextureDimension dimension = TextureDimension::e2D;\n        Extent3D size;\n        TextureFormat format;\n        uint32_t mipLevelCount = 1;\n        uint32_t sampleCount = 1;\n        uint32_t viewFormatCount = 0;\n        TextureFormat const * viewFormats;\n    };\n\n    struct VertexBufferLayout {\n        uint64_t arrayStride;\n        VertexStepMode stepMode = VertexStepMode::Vertex;\n        uint32_t attributeCount;\n        VertexAttribute const * attributes;\n    };\n\n    struct BindGroupLayoutDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t entryCount;\n        BindGroupLayoutEntry const * entries;\n    };\n\n    struct ColorTargetState {\n        ChainedStruct const * nextInChain = nullptr;\n        TextureFormat format;\n        BlendState const * blend = nullptr;\n        ColorWriteMask writeMask = ColorWriteMask::All;\n    };\n\n    struct ComputePipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout = nullptr;\n        ProgrammableStageDescriptor compute;\n    };\n\n    struct DeviceDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t requiredFeaturesCount = 0;\n        FeatureName const * requiredFeatures = nullptr;\n        RequiredLimits const * requiredLimits = nullptr;\n        QueueDescriptor defaultQueue;\n    };\n\n    struct RenderPassDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        uint32_t colorAttachmentCount;\n        RenderPassColorAttachment const * colorAttachments;\n        RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n        QuerySet occlusionQuerySet = nullptr;\n        uint32_t timestampWriteCount = 0;\n        RenderPassTimestampWrite const * timestampWrites;\n    };\n\n    struct VertexState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n        uint32_t bufferCount = 0;\n        VertexBufferLayout const * buffers;\n    };\n\n    struct FragmentState {\n        ChainedStruct const * nextInChain = nullptr;\n        ShaderModule module;\n        char const * entryPoint;\n        uint32_t constantCount = 0;\n        ConstantEntry const * constants;\n        uint32_t targetCount;\n        ColorTargetState const * targets;\n    };\n\n    struct RenderPipelineDescriptor {\n        ChainedStruct const * nextInChain = nullptr;\n        char const * label = nullptr;\n        PipelineLayout layout = nullptr;\n        VertexState vertex;\n        PrimitiveState primitive;\n        DepthStencilState const * depthStencil = nullptr;\n        MultisampleState multisample;\n        FragmentState const * fragment = nullptr;\n    };\n\n\n    // The operators of EnumClassBitmmasks in the dawn:: namespace need to be imported\n    // in the wgpu namespace for Argument Dependent Lookup.\n    DAWN_IMPORT_BITMASK_OPERATORS\n}  // namespace wgpu\n\nnamespace dawn {\n    template<>\n    struct IsDawnBitmask<wgpu::BufferUsage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ColorWriteMask> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::MapMode> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::ShaderStage> {\n        static constexpr bool enable = true;\n    };\n\n    template<>\n    struct IsDawnBitmask<wgpu::TextureUsage> {\n        static constexpr bool enable = true;\n    };\n\n} // namespace dawn\n\n#endif // WEBGPU_CPP_H_\n", "./include/dawn/dawn_wsi.h": "// Copyright 2017 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_DAWN_WSI_H_\n#define INCLUDE_DAWN_DAWN_WSI_H_\n\n#include \"dawn/webgpu.h\"\n\n// Error message (or nullptr if there was no error)\ntypedef const char* DawnSwapChainError;\nconstexpr DawnSwapChainError DAWN_SWAP_CHAIN_NO_ERROR = nullptr;\n\ntypedef struct {\n    /// Backend-specific texture id/name/pointer\n    union {\n        void* ptr;\n        uint64_t u64;\n        uint32_t u32;\n    } texture;\n} DawnSwapChainNextTexture;\n\ntypedef struct {\n    /// Initialize the swap chain implementation.\n    ///   (*wsiContext) is one of DawnWSIContext{D3D12,Metal,GL}\n    void (*Init)(void* userData, void* wsiContext);\n\n    /// Destroy the swap chain implementation.\n    void (*Destroy)(void* userData);\n\n    /// Configure/reconfigure the swap chain.\n    DawnSwapChainError (*Configure)(void* userData,\n                                    WGPUTextureFormat format,\n                                    WGPUTextureUsage allowedUsage,\n                                    uint32_t width,\n                                    uint32_t height);\n\n    /// Acquire the next texture from the swap chain.\n    DawnSwapChainError (*GetNextTexture)(void* userData, DawnSwapChainNextTexture* nextTexture);\n\n    /// Present the last acquired texture to the screen.\n    DawnSwapChainError (*Present)(void* userData);\n\n    /// Each function is called with userData as its first argument.\n    void* userData;\n\n    /// For use by the D3D12 and Vulkan backends: how the swapchain will use the texture.\n    WGPUTextureUsage textureUsage;\n} DawnSwapChainImplementation;\n\n#if defined(DAWN_ENABLE_BACKEND_D3D12) && defined(__cplusplus)\nstruct DawnWSIContextD3D12 {\n    WGPUDevice device = nullptr;\n};\n#endif\n\n#if defined(DAWN_ENABLE_BACKEND_METAL) && defined(__OBJC__)\n#import <Metal/Metal.h>\n\nstruct DawnWSIContextMetal {\n    id<MTLDevice> device = nil;\n    id<MTLCommandQueue> queue = nil;\n};\n#endif\n\n#ifdef DAWN_ENABLE_BACKEND_OPENGL\ntypedef struct {\n} DawnWSIContextGL;\n#endif\n\n#ifdef DAWN_ENABLE_BACKEND_VULKAN\ntypedef struct {\n} DawnWSIContextVulkan;\n#endif\n\n#endif  // INCLUDE_DAWN_DAWN_WSI_H_\n", "./include/dawn/dawn_thread_dispatch_proc.h": "// Copyright 2020 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_DAWN_THREAD_DISPATCH_PROC_H_\n#define INCLUDE_DAWN_DAWN_THREAD_DISPATCH_PROC_H_\n\n#include \"dawn/dawn_proc.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Call dawnProcSetProcs(&dawnThreadDispatchProcTable) and then use dawnProcSetPerThreadProcs\n// to set per-thread procs.\nWGPU_EXPORT extern DawnProcTable dawnThreadDispatchProcTable;\nWGPU_EXPORT void dawnProcSetPerThreadProcs(const DawnProcTable* procs);\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n#endif  // INCLUDE_DAWN_DAWN_THREAD_DISPATCH_PROC_H_\n", "./include/dawn/dawn_proc_table.h": "\n#ifndef DAWN_DAWN_PROC_TABLE_H_\n#define DAWN_DAWN_PROC_TABLE_H_\n\n#include \"dawn/webgpu.h\"\n\n// Note: Often allocated as a static global. Do not add a complex constructor.\ntypedef struct DawnProcTable {\n    WGPUProcCreateInstance createInstance;\n    WGPUProcGetProcAddress getProcAddress;\n\n    WGPUProcAdapterCreateDevice adapterCreateDevice;\n    WGPUProcAdapterEnumerateFeatures adapterEnumerateFeatures;\n    WGPUProcAdapterGetLimits adapterGetLimits;\n    WGPUProcAdapterGetProperties adapterGetProperties;\n    WGPUProcAdapterHasFeature adapterHasFeature;\n    WGPUProcAdapterRequestDevice adapterRequestDevice;\n    WGPUProcAdapterReference adapterReference;\n    WGPUProcAdapterRelease adapterRelease;\n\n    WGPUProcBindGroupSetLabel bindGroupSetLabel;\n    WGPUProcBindGroupReference bindGroupReference;\n    WGPUProcBindGroupRelease bindGroupRelease;\n\n    WGPUProcBindGroupLayoutSetLabel bindGroupLayoutSetLabel;\n    WGPUProcBindGroupLayoutReference bindGroupLayoutReference;\n    WGPUProcBindGroupLayoutRelease bindGroupLayoutRelease;\n\n    WGPUProcBufferDestroy bufferDestroy;\n    WGPUProcBufferGetConstMappedRange bufferGetConstMappedRange;\n    WGPUProcBufferGetMapState bufferGetMapState;\n    WGPUProcBufferGetMappedRange bufferGetMappedRange;\n    WGPUProcBufferGetSize bufferGetSize;\n    WGPUProcBufferGetUsage bufferGetUsage;\n    WGPUProcBufferMapAsync bufferMapAsync;\n    WGPUProcBufferSetLabel bufferSetLabel;\n    WGPUProcBufferUnmap bufferUnmap;\n    WGPUProcBufferReference bufferReference;\n    WGPUProcBufferRelease bufferRelease;\n\n    WGPUProcCommandBufferSetLabel commandBufferSetLabel;\n    WGPUProcCommandBufferReference commandBufferReference;\n    WGPUProcCommandBufferRelease commandBufferRelease;\n\n    WGPUProcCommandEncoderBeginComputePass commandEncoderBeginComputePass;\n    WGPUProcCommandEncoderBeginRenderPass commandEncoderBeginRenderPass;\n    WGPUProcCommandEncoderClearBuffer commandEncoderClearBuffer;\n    WGPUProcCommandEncoderCopyBufferToBuffer commandEncoderCopyBufferToBuffer;\n    WGPUProcCommandEncoderCopyBufferToTexture commandEncoderCopyBufferToTexture;\n    WGPUProcCommandEncoderCopyTextureToBuffer commandEncoderCopyTextureToBuffer;\n    WGPUProcCommandEncoderCopyTextureToTexture commandEncoderCopyTextureToTexture;\n    WGPUProcCommandEncoderCopyTextureToTextureInternal commandEncoderCopyTextureToTextureInternal;\n    WGPUProcCommandEncoderFinish commandEncoderFinish;\n    WGPUProcCommandEncoderInjectValidationError commandEncoderInjectValidationError;\n    WGPUProcCommandEncoderInsertDebugMarker commandEncoderInsertDebugMarker;\n    WGPUProcCommandEncoderPopDebugGroup commandEncoderPopDebugGroup;\n    WGPUProcCommandEncoderPushDebugGroup commandEncoderPushDebugGroup;\n    WGPUProcCommandEncoderResolveQuerySet commandEncoderResolveQuerySet;\n    WGPUProcCommandEncoderSetLabel commandEncoderSetLabel;\n    WGPUProcCommandEncoderWriteBuffer commandEncoderWriteBuffer;\n    WGPUProcCommandEncoderWriteTimestamp commandEncoderWriteTimestamp;\n    WGPUProcCommandEncoderReference commandEncoderReference;\n    WGPUProcCommandEncoderRelease commandEncoderRelease;\n\n    WGPUProcComputePassEncoderDispatch computePassEncoderDispatch;\n    WGPUProcComputePassEncoderDispatchIndirect computePassEncoderDispatchIndirect;\n    WGPUProcComputePassEncoderDispatchWorkgroups computePassEncoderDispatchWorkgroups;\n    WGPUProcComputePassEncoderDispatchWorkgroupsIndirect computePassEncoderDispatchWorkgroupsIndirect;\n    WGPUProcComputePassEncoderEnd computePassEncoderEnd;\n    WGPUProcComputePassEncoderEndPass computePassEncoderEndPass;\n    WGPUProcComputePassEncoderInsertDebugMarker computePassEncoderInsertDebugMarker;\n    WGPUProcComputePassEncoderPopDebugGroup computePassEncoderPopDebugGroup;\n    WGPUProcComputePassEncoderPushDebugGroup computePassEncoderPushDebugGroup;\n    WGPUProcComputePassEncoderSetBindGroup computePassEncoderSetBindGroup;\n    WGPUProcComputePassEncoderSetLabel computePassEncoderSetLabel;\n    WGPUProcComputePassEncoderSetPipeline computePassEncoderSetPipeline;\n    WGPUProcComputePassEncoderWriteTimestamp computePassEncoderWriteTimestamp;\n    WGPUProcComputePassEncoderReference computePassEncoderReference;\n    WGPUProcComputePassEncoderRelease computePassEncoderRelease;\n\n    WGPUProcComputePipelineGetBindGroupLayout computePipelineGetBindGroupLayout;\n    WGPUProcComputePipelineSetLabel computePipelineSetLabel;\n    WGPUProcComputePipelineReference computePipelineReference;\n    WGPUProcComputePipelineRelease computePipelineRelease;\n\n    WGPUProcDeviceCreateBindGroup deviceCreateBindGroup;\n    WGPUProcDeviceCreateBindGroupLayout deviceCreateBindGroupLayout;\n    WGPUProcDeviceCreateBuffer deviceCreateBuffer;\n    WGPUProcDeviceCreateCommandEncoder deviceCreateCommandEncoder;\n    WGPUProcDeviceCreateComputePipeline deviceCreateComputePipeline;\n    WGPUProcDeviceCreateComputePipelineAsync deviceCreateComputePipelineAsync;\n    WGPUProcDeviceCreateErrorBuffer deviceCreateErrorBuffer;\n    WGPUProcDeviceCreateErrorExternalTexture deviceCreateErrorExternalTexture;\n    WGPUProcDeviceCreateErrorTexture deviceCreateErrorTexture;\n    WGPUProcDeviceCreateExternalTexture deviceCreateExternalTexture;\n    WGPUProcDeviceCreatePipelineLayout deviceCreatePipelineLayout;\n    WGPUProcDeviceCreateQuerySet deviceCreateQuerySet;\n    WGPUProcDeviceCreateRenderBundleEncoder deviceCreateRenderBundleEncoder;\n    WGPUProcDeviceCreateRenderPipeline deviceCreateRenderPipeline;\n    WGPUProcDeviceCreateRenderPipelineAsync deviceCreateRenderPipelineAsync;\n    WGPUProcDeviceCreateSampler deviceCreateSampler;\n    WGPUProcDeviceCreateShaderModule deviceCreateShaderModule;\n    WGPUProcDeviceCreateSwapChain deviceCreateSwapChain;\n    WGPUProcDeviceCreateTexture deviceCreateTexture;\n    WGPUProcDeviceDestroy deviceDestroy;\n    WGPUProcDeviceEnumerateFeatures deviceEnumerateFeatures;\n    WGPUProcDeviceForceLoss deviceForceLoss;\n    WGPUProcDeviceGetAdapter deviceGetAdapter;\n    WGPUProcDeviceGetLimits deviceGetLimits;\n    WGPUProcDeviceGetQueue deviceGetQueue;\n    WGPUProcDeviceHasFeature deviceHasFeature;\n    WGPUProcDeviceInjectError deviceInjectError;\n    WGPUProcDevicePopErrorScope devicePopErrorScope;\n    WGPUProcDevicePushErrorScope devicePushErrorScope;\n    WGPUProcDeviceSetDeviceLostCallback deviceSetDeviceLostCallback;\n    WGPUProcDeviceSetLabel deviceSetLabel;\n    WGPUProcDeviceSetLoggingCallback deviceSetLoggingCallback;\n    WGPUProcDeviceSetUncapturedErrorCallback deviceSetUncapturedErrorCallback;\n    WGPUProcDeviceTick deviceTick;\n    WGPUProcDeviceValidateTextureDescriptor deviceValidateTextureDescriptor;\n    WGPUProcDeviceReference deviceReference;\n    WGPUProcDeviceRelease deviceRelease;\n\n    WGPUProcExternalTextureDestroy externalTextureDestroy;\n    WGPUProcExternalTextureSetLabel externalTextureSetLabel;\n    WGPUProcExternalTextureReference externalTextureReference;\n    WGPUProcExternalTextureRelease externalTextureRelease;\n\n    WGPUProcInstanceCreateSurface instanceCreateSurface;\n    WGPUProcInstanceRequestAdapter instanceRequestAdapter;\n    WGPUProcInstanceReference instanceReference;\n    WGPUProcInstanceRelease instanceRelease;\n\n    WGPUProcPipelineLayoutSetLabel pipelineLayoutSetLabel;\n    WGPUProcPipelineLayoutReference pipelineLayoutReference;\n    WGPUProcPipelineLayoutRelease pipelineLayoutRelease;\n\n    WGPUProcQuerySetDestroy querySetDestroy;\n    WGPUProcQuerySetGetCount querySetGetCount;\n    WGPUProcQuerySetGetType querySetGetType;\n    WGPUProcQuerySetSetLabel querySetSetLabel;\n    WGPUProcQuerySetReference querySetReference;\n    WGPUProcQuerySetRelease querySetRelease;\n\n    WGPUProcQueueCopyExternalTextureForBrowser queueCopyExternalTextureForBrowser;\n    WGPUProcQueueCopyTextureForBrowser queueCopyTextureForBrowser;\n    WGPUProcQueueOnSubmittedWorkDone queueOnSubmittedWorkDone;\n    WGPUProcQueueSetLabel queueSetLabel;\n    WGPUProcQueueSubmit queueSubmit;\n    WGPUProcQueueWriteBuffer queueWriteBuffer;\n    WGPUProcQueueWriteTexture queueWriteTexture;\n    WGPUProcQueueReference queueReference;\n    WGPUProcQueueRelease queueRelease;\n\n    WGPUProcRenderBundleReference renderBundleReference;\n    WGPUProcRenderBundleRelease renderBundleRelease;\n\n    WGPUProcRenderBundleEncoderDraw renderBundleEncoderDraw;\n    WGPUProcRenderBundleEncoderDrawIndexed renderBundleEncoderDrawIndexed;\n    WGPUProcRenderBundleEncoderDrawIndexedIndirect renderBundleEncoderDrawIndexedIndirect;\n    WGPUProcRenderBundleEncoderDrawIndirect renderBundleEncoderDrawIndirect;\n    WGPUProcRenderBundleEncoderFinish renderBundleEncoderFinish;\n    WGPUProcRenderBundleEncoderInsertDebugMarker renderBundleEncoderInsertDebugMarker;\n    WGPUProcRenderBundleEncoderPopDebugGroup renderBundleEncoderPopDebugGroup;\n    WGPUProcRenderBundleEncoderPushDebugGroup renderBundleEncoderPushDebugGroup;\n    WGPUProcRenderBundleEncoderSetBindGroup renderBundleEncoderSetBindGroup;\n    WGPUProcRenderBundleEncoderSetIndexBuffer renderBundleEncoderSetIndexBuffer;\n    WGPUProcRenderBundleEncoderSetLabel renderBundleEncoderSetLabel;\n    WGPUProcRenderBundleEncoderSetPipeline renderBundleEncoderSetPipeline;\n    WGPUProcRenderBundleEncoderSetVertexBuffer renderBundleEncoderSetVertexBuffer;\n    WGPUProcRenderBundleEncoderReference renderBundleEncoderReference;\n    WGPUProcRenderBundleEncoderRelease renderBundleEncoderRelease;\n\n    WGPUProcRenderPassEncoderBeginOcclusionQuery renderPassEncoderBeginOcclusionQuery;\n    WGPUProcRenderPassEncoderDraw renderPassEncoderDraw;\n    WGPUProcRenderPassEncoderDrawIndexed renderPassEncoderDrawIndexed;\n    WGPUProcRenderPassEncoderDrawIndexedIndirect renderPassEncoderDrawIndexedIndirect;\n    WGPUProcRenderPassEncoderDrawIndirect renderPassEncoderDrawIndirect;\n    WGPUProcRenderPassEncoderEnd renderPassEncoderEnd;\n    WGPUProcRenderPassEncoderEndOcclusionQuery renderPassEncoderEndOcclusionQuery;\n    WGPUProcRenderPassEncoderEndPass renderPassEncoderEndPass;\n    WGPUProcRenderPassEncoderExecuteBundles renderPassEncoderExecuteBundles;\n    WGPUProcRenderPassEncoderInsertDebugMarker renderPassEncoderInsertDebugMarker;\n    WGPUProcRenderPassEncoderPopDebugGroup renderPassEncoderPopDebugGroup;\n    WGPUProcRenderPassEncoderPushDebugGroup renderPassEncoderPushDebugGroup;\n    WGPUProcRenderPassEncoderSetBindGroup renderPassEncoderSetBindGroup;\n    WGPUProcRenderPassEncoderSetBlendConstant renderPassEncoderSetBlendConstant;\n    WGPUProcRenderPassEncoderSetIndexBuffer renderPassEncoderSetIndexBuffer;\n    WGPUProcRenderPassEncoderSetLabel renderPassEncoderSetLabel;\n    WGPUProcRenderPassEncoderSetPipeline renderPassEncoderSetPipeline;\n    WGPUProcRenderPassEncoderSetScissorRect renderPassEncoderSetScissorRect;\n    WGPUProcRenderPassEncoderSetStencilReference renderPassEncoderSetStencilReference;\n    WGPUProcRenderPassEncoderSetVertexBuffer renderPassEncoderSetVertexBuffer;\n    WGPUProcRenderPassEncoderSetViewport renderPassEncoderSetViewport;\n    WGPUProcRenderPassEncoderWriteTimestamp renderPassEncoderWriteTimestamp;\n    WGPUProcRenderPassEncoderReference renderPassEncoderReference;\n    WGPUProcRenderPassEncoderRelease renderPassEncoderRelease;\n\n    WGPUProcRenderPipelineGetBindGroupLayout renderPipelineGetBindGroupLayout;\n    WGPUProcRenderPipelineSetLabel renderPipelineSetLabel;\n    WGPUProcRenderPipelineReference renderPipelineReference;\n    WGPUProcRenderPipelineRelease renderPipelineRelease;\n\n    WGPUProcSamplerSetLabel samplerSetLabel;\n    WGPUProcSamplerReference samplerReference;\n    WGPUProcSamplerRelease samplerRelease;\n\n    WGPUProcShaderModuleGetCompilationInfo shaderModuleGetCompilationInfo;\n    WGPUProcShaderModuleSetLabel shaderModuleSetLabel;\n    WGPUProcShaderModuleReference shaderModuleReference;\n    WGPUProcShaderModuleRelease shaderModuleRelease;\n\n    WGPUProcSurfaceReference surfaceReference;\n    WGPUProcSurfaceRelease surfaceRelease;\n\n    WGPUProcSwapChainConfigure swapChainConfigure;\n    WGPUProcSwapChainGetCurrentTextureView swapChainGetCurrentTextureView;\n    WGPUProcSwapChainPresent swapChainPresent;\n    WGPUProcSwapChainReference swapChainReference;\n    WGPUProcSwapChainRelease swapChainRelease;\n\n    WGPUProcTextureCreateView textureCreateView;\n    WGPUProcTextureDestroy textureDestroy;\n    WGPUProcTextureGetDepthOrArrayLayers textureGetDepthOrArrayLayers;\n    WGPUProcTextureGetDimension textureGetDimension;\n    WGPUProcTextureGetFormat textureGetFormat;\n    WGPUProcTextureGetHeight textureGetHeight;\n    WGPUProcTextureGetMipLevelCount textureGetMipLevelCount;\n    WGPUProcTextureGetSampleCount textureGetSampleCount;\n    WGPUProcTextureGetUsage textureGetUsage;\n    WGPUProcTextureGetWidth textureGetWidth;\n    WGPUProcTextureSetLabel textureSetLabel;\n    WGPUProcTextureReference textureReference;\n    WGPUProcTextureRelease textureRelease;\n\n    WGPUProcTextureViewSetLabel textureViewSetLabel;\n    WGPUProcTextureViewReference textureViewReference;\n    WGPUProcTextureViewRelease textureViewRelease;\n\n} DawnProcTable;\n\n#endif  // DAWN_DAWN_PROC_TABLE_H_\n", "./include/dawn/dawn_proc.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_DAWN_PROC_H_\n#define INCLUDE_DAWN_DAWN_PROC_H_\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/webgpu.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Sets the static proctable used by libdawn_proc to implement the Dawn entrypoints. Passing NULL\n// for `procs` sets up the null proctable that contains only null function pointers. It is the\n// default value of the proctable. Setting the proctable back to null is good practice when you\n// are done using libdawn_proc since further usage will cause a segfault instead of calling an\n// unexpected function.\nWGPU_EXPORT void dawnProcSetProcs(const DawnProcTable* procs);\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n#endif  // INCLUDE_DAWN_DAWN_PROC_H_\n", "./include/dawn/webgpu_cpp_print.h": "\n#ifndef WEBGPU_CPP_PRINT_H_\n#define WEBGPU_CPP_PRINT_H_\n\n#include \"dawn/webgpu_cpp.h\"\n\n#include <iomanip>\n#include <ios>\n#include <ostream>\n#include <type_traits>\n\nnamespace wgpu {\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AdapterType value) {\n      switch (value) {\n      case AdapterType::DiscreteGPU:\n        o << \"AdapterType::DiscreteGPU\";\n        break;\n      case AdapterType::IntegratedGPU:\n        o << \"AdapterType::IntegratedGPU\";\n        break;\n      case AdapterType::CPU:\n        o << \"AdapterType::CPU\";\n        break;\n      case AdapterType::Unknown:\n        o << \"AdapterType::Unknown\";\n        break;\n          default:\n            o << \"AdapterType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AdapterType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AddressMode value) {\n      switch (value) {\n      case AddressMode::Repeat:\n        o << \"AddressMode::Repeat\";\n        break;\n      case AddressMode::MirrorRepeat:\n        o << \"AddressMode::MirrorRepeat\";\n        break;\n      case AddressMode::ClampToEdge:\n        o << \"AddressMode::ClampToEdge\";\n        break;\n          default:\n            o << \"AddressMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AddressMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AlphaMode value) {\n      switch (value) {\n      case AlphaMode::Premultiplied:\n        o << \"AlphaMode::Premultiplied\";\n        break;\n      case AlphaMode::Unpremultiplied:\n        o << \"AlphaMode::Unpremultiplied\";\n        break;\n      case AlphaMode::Opaque:\n        o << \"AlphaMode::Opaque\";\n        break;\n          default:\n            o << \"AlphaMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AlphaMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BackendType value) {\n      switch (value) {\n      case BackendType::Null:\n        o << \"BackendType::Null\";\n        break;\n      case BackendType::WebGPU:\n        o << \"BackendType::WebGPU\";\n        break;\n      case BackendType::D3D11:\n        o << \"BackendType::D3D11\";\n        break;\n      case BackendType::D3D12:\n        o << \"BackendType::D3D12\";\n        break;\n      case BackendType::Metal:\n        o << \"BackendType::Metal\";\n        break;\n      case BackendType::Vulkan:\n        o << \"BackendType::Vulkan\";\n        break;\n      case BackendType::OpenGL:\n        o << \"BackendType::OpenGL\";\n        break;\n      case BackendType::OpenGLES:\n        o << \"BackendType::OpenGLES\";\n        break;\n          default:\n            o << \"BackendType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BackendType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendFactor value) {\n      switch (value) {\n      case BlendFactor::Zero:\n        o << \"BlendFactor::Zero\";\n        break;\n      case BlendFactor::One:\n        o << \"BlendFactor::One\";\n        break;\n      case BlendFactor::Src:\n        o << \"BlendFactor::Src\";\n        break;\n      case BlendFactor::OneMinusSrc:\n        o << \"BlendFactor::OneMinusSrc\";\n        break;\n      case BlendFactor::SrcAlpha:\n        o << \"BlendFactor::SrcAlpha\";\n        break;\n      case BlendFactor::OneMinusSrcAlpha:\n        o << \"BlendFactor::OneMinusSrcAlpha\";\n        break;\n      case BlendFactor::Dst:\n        o << \"BlendFactor::Dst\";\n        break;\n      case BlendFactor::OneMinusDst:\n        o << \"BlendFactor::OneMinusDst\";\n        break;\n      case BlendFactor::DstAlpha:\n        o << \"BlendFactor::DstAlpha\";\n        break;\n      case BlendFactor::OneMinusDstAlpha:\n        o << \"BlendFactor::OneMinusDstAlpha\";\n        break;\n      case BlendFactor::SrcAlphaSaturated:\n        o << \"BlendFactor::SrcAlphaSaturated\";\n        break;\n      case BlendFactor::Constant:\n        o << \"BlendFactor::Constant\";\n        break;\n      case BlendFactor::OneMinusConstant:\n        o << \"BlendFactor::OneMinusConstant\";\n        break;\n          default:\n            o << \"BlendFactor::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendFactor>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendOperation value) {\n      switch (value) {\n      case BlendOperation::Add:\n        o << \"BlendOperation::Add\";\n        break;\n      case BlendOperation::Subtract:\n        o << \"BlendOperation::Subtract\";\n        break;\n      case BlendOperation::ReverseSubtract:\n        o << \"BlendOperation::ReverseSubtract\";\n        break;\n      case BlendOperation::Min:\n        o << \"BlendOperation::Min\";\n        break;\n      case BlendOperation::Max:\n        o << \"BlendOperation::Max\";\n        break;\n          default:\n            o << \"BlendOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferBindingType value) {\n      switch (value) {\n      case BufferBindingType::Undefined:\n        o << \"BufferBindingType::Undefined\";\n        break;\n      case BufferBindingType::Uniform:\n        o << \"BufferBindingType::Uniform\";\n        break;\n      case BufferBindingType::Storage:\n        o << \"BufferBindingType::Storage\";\n        break;\n      case BufferBindingType::ReadOnlyStorage:\n        o << \"BufferBindingType::ReadOnlyStorage\";\n        break;\n          default:\n            o << \"BufferBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapAsyncStatus value) {\n      switch (value) {\n      case BufferMapAsyncStatus::Success:\n        o << \"BufferMapAsyncStatus::Success\";\n        break;\n      case BufferMapAsyncStatus::Error:\n        o << \"BufferMapAsyncStatus::Error\";\n        break;\n      case BufferMapAsyncStatus::Unknown:\n        o << \"BufferMapAsyncStatus::Unknown\";\n        break;\n      case BufferMapAsyncStatus::DeviceLost:\n        o << \"BufferMapAsyncStatus::DeviceLost\";\n        break;\n      case BufferMapAsyncStatus::DestroyedBeforeCallback:\n        o << \"BufferMapAsyncStatus::DestroyedBeforeCallback\";\n        break;\n      case BufferMapAsyncStatus::UnmappedBeforeCallback:\n        o << \"BufferMapAsyncStatus::UnmappedBeforeCallback\";\n        break;\n          default:\n            o << \"BufferMapAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapState value) {\n      switch (value) {\n      case BufferMapState::Unmapped:\n        o << \"BufferMapState::Unmapped\";\n        break;\n      case BufferMapState::Pending:\n        o << \"BufferMapState::Pending\";\n        break;\n      case BufferMapState::Mapped:\n        o << \"BufferMapState::Mapped\";\n        break;\n          default:\n            o << \"BufferMapState::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapState>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompareFunction value) {\n      switch (value) {\n      case CompareFunction::Undefined:\n        o << \"CompareFunction::Undefined\";\n        break;\n      case CompareFunction::Never:\n        o << \"CompareFunction::Never\";\n        break;\n      case CompareFunction::Less:\n        o << \"CompareFunction::Less\";\n        break;\n      case CompareFunction::LessEqual:\n        o << \"CompareFunction::LessEqual\";\n        break;\n      case CompareFunction::Greater:\n        o << \"CompareFunction::Greater\";\n        break;\n      case CompareFunction::GreaterEqual:\n        o << \"CompareFunction::GreaterEqual\";\n        break;\n      case CompareFunction::Equal:\n        o << \"CompareFunction::Equal\";\n        break;\n      case CompareFunction::NotEqual:\n        o << \"CompareFunction::NotEqual\";\n        break;\n      case CompareFunction::Always:\n        o << \"CompareFunction::Always\";\n        break;\n          default:\n            o << \"CompareFunction::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompareFunction>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationInfoRequestStatus value) {\n      switch (value) {\n      case CompilationInfoRequestStatus::Success:\n        o << \"CompilationInfoRequestStatus::Success\";\n        break;\n      case CompilationInfoRequestStatus::Error:\n        o << \"CompilationInfoRequestStatus::Error\";\n        break;\n      case CompilationInfoRequestStatus::DeviceLost:\n        o << \"CompilationInfoRequestStatus::DeviceLost\";\n        break;\n      case CompilationInfoRequestStatus::Unknown:\n        o << \"CompilationInfoRequestStatus::Unknown\";\n        break;\n          default:\n            o << \"CompilationInfoRequestStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationInfoRequestStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationMessageType value) {\n      switch (value) {\n      case CompilationMessageType::Error:\n        o << \"CompilationMessageType::Error\";\n        break;\n      case CompilationMessageType::Warning:\n        o << \"CompilationMessageType::Warning\";\n        break;\n      case CompilationMessageType::Info:\n        o << \"CompilationMessageType::Info\";\n        break;\n          default:\n            o << \"CompilationMessageType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationMessageType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ComputePassTimestampLocation value) {\n      switch (value) {\n      case ComputePassTimestampLocation::Beginning:\n        o << \"ComputePassTimestampLocation::Beginning\";\n        break;\n      case ComputePassTimestampLocation::End:\n        o << \"ComputePassTimestampLocation::End\";\n        break;\n          default:\n            o << \"ComputePassTimestampLocation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ComputePassTimestampLocation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CreatePipelineAsyncStatus value) {\n      switch (value) {\n      case CreatePipelineAsyncStatus::Success:\n        o << \"CreatePipelineAsyncStatus::Success\";\n        break;\n      case CreatePipelineAsyncStatus::Error:\n        o << \"CreatePipelineAsyncStatus::Error\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceLost:\n        o << \"CreatePipelineAsyncStatus::DeviceLost\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceDestroyed:\n        o << \"CreatePipelineAsyncStatus::DeviceDestroyed\";\n        break;\n      case CreatePipelineAsyncStatus::Unknown:\n        o << \"CreatePipelineAsyncStatus::Unknown\";\n        break;\n          default:\n            o << \"CreatePipelineAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CreatePipelineAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CullMode value) {\n      switch (value) {\n      case CullMode::None:\n        o << \"CullMode::None\";\n        break;\n      case CullMode::Front:\n        o << \"CullMode::Front\";\n        break;\n      case CullMode::Back:\n        o << \"CullMode::Back\";\n        break;\n          default:\n            o << \"CullMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CullMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, DeviceLostReason value) {\n      switch (value) {\n      case DeviceLostReason::Undefined:\n        o << \"DeviceLostReason::Undefined\";\n        break;\n      case DeviceLostReason::Destroyed:\n        o << \"DeviceLostReason::Destroyed\";\n        break;\n          default:\n            o << \"DeviceLostReason::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<DeviceLostReason>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorFilter value) {\n      switch (value) {\n      case ErrorFilter::Validation:\n        o << \"ErrorFilter::Validation\";\n        break;\n      case ErrorFilter::OutOfMemory:\n        o << \"ErrorFilter::OutOfMemory\";\n        break;\n      case ErrorFilter::Internal:\n        o << \"ErrorFilter::Internal\";\n        break;\n          default:\n            o << \"ErrorFilter::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorFilter>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorType value) {\n      switch (value) {\n      case ErrorType::NoError:\n        o << \"ErrorType::NoError\";\n        break;\n      case ErrorType::Validation:\n        o << \"ErrorType::Validation\";\n        break;\n      case ErrorType::OutOfMemory:\n        o << \"ErrorType::OutOfMemory\";\n        break;\n      case ErrorType::Internal:\n        o << \"ErrorType::Internal\";\n        break;\n      case ErrorType::Unknown:\n        o << \"ErrorType::Unknown\";\n        break;\n      case ErrorType::DeviceLost:\n        o << \"ErrorType::DeviceLost\";\n        break;\n          default:\n            o << \"ErrorType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ExternalTextureRotation value) {\n      switch (value) {\n      case ExternalTextureRotation::Rotate0Degrees:\n        o << \"ExternalTextureRotation::Rotate0Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate90Degrees:\n        o << \"ExternalTextureRotation::Rotate90Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate180Degrees:\n        o << \"ExternalTextureRotation::Rotate180Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate270Degrees:\n        o << \"ExternalTextureRotation::Rotate270Degrees\";\n        break;\n          default:\n            o << \"ExternalTextureRotation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ExternalTextureRotation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FeatureName value) {\n      switch (value) {\n      case FeatureName::Undefined:\n        o << \"FeatureName::Undefined\";\n        break;\n      case FeatureName::DepthClipControl:\n        o << \"FeatureName::DepthClipControl\";\n        break;\n      case FeatureName::Depth32FloatStencil8:\n        o << \"FeatureName::Depth32FloatStencil8\";\n        break;\n      case FeatureName::TimestampQuery:\n        o << \"FeatureName::TimestampQuery\";\n        break;\n      case FeatureName::PipelineStatisticsQuery:\n        o << \"FeatureName::PipelineStatisticsQuery\";\n        break;\n      case FeatureName::TextureCompressionBC:\n        o << \"FeatureName::TextureCompressionBC\";\n        break;\n      case FeatureName::TextureCompressionETC2:\n        o << \"FeatureName::TextureCompressionETC2\";\n        break;\n      case FeatureName::TextureCompressionASTC:\n        o << \"FeatureName::TextureCompressionASTC\";\n        break;\n      case FeatureName::IndirectFirstInstance:\n        o << \"FeatureName::IndirectFirstInstance\";\n        break;\n      case FeatureName::ShaderF16:\n        o << \"FeatureName::ShaderF16\";\n        break;\n      case FeatureName::RG11B10UfloatRenderable:\n        o << \"FeatureName::RG11B10UfloatRenderable\";\n        break;\n      case FeatureName::DawnShaderFloat16:\n        o << \"FeatureName::DawnShaderFloat16\";\n        break;\n      case FeatureName::DawnInternalUsages:\n        o << \"FeatureName::DawnInternalUsages\";\n        break;\n      case FeatureName::DawnMultiPlanarFormats:\n        o << \"FeatureName::DawnMultiPlanarFormats\";\n        break;\n      case FeatureName::DawnNative:\n        o << \"FeatureName::DawnNative\";\n        break;\n      case FeatureName::ChromiumExperimentalDp4a:\n        o << \"FeatureName::ChromiumExperimentalDp4a\";\n        break;\n      case FeatureName::TimestampQueryInsidePasses:\n        o << \"FeatureName::TimestampQueryInsidePasses\";\n        break;\n          default:\n            o << \"FeatureName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FeatureName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FilterMode value) {\n      switch (value) {\n      case FilterMode::Nearest:\n        o << \"FilterMode::Nearest\";\n        break;\n      case FilterMode::Linear:\n        o << \"FilterMode::Linear\";\n        break;\n          default:\n            o << \"FilterMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FilterMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FrontFace value) {\n      switch (value) {\n      case FrontFace::CCW:\n        o << \"FrontFace::CCW\";\n        break;\n      case FrontFace::CW:\n        o << \"FrontFace::CW\";\n        break;\n          default:\n            o << \"FrontFace::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FrontFace>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, IndexFormat value) {\n      switch (value) {\n      case IndexFormat::Undefined:\n        o << \"IndexFormat::Undefined\";\n        break;\n      case IndexFormat::Uint16:\n        o << \"IndexFormat::Uint16\";\n        break;\n      case IndexFormat::Uint32:\n        o << \"IndexFormat::Uint32\";\n        break;\n          default:\n            o << \"IndexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<IndexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoadOp value) {\n      switch (value) {\n      case LoadOp::Undefined:\n        o << \"LoadOp::Undefined\";\n        break;\n      case LoadOp::Clear:\n        o << \"LoadOp::Clear\";\n        break;\n      case LoadOp::Load:\n        o << \"LoadOp::Load\";\n        break;\n          default:\n            o << \"LoadOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoadOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoggingType value) {\n      switch (value) {\n      case LoggingType::Verbose:\n        o << \"LoggingType::Verbose\";\n        break;\n      case LoggingType::Info:\n        o << \"LoggingType::Info\";\n        break;\n      case LoggingType::Warning:\n        o << \"LoggingType::Warning\";\n        break;\n      case LoggingType::Error:\n        o << \"LoggingType::Error\";\n        break;\n          default:\n            o << \"LoggingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoggingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PipelineStatisticName value) {\n      switch (value) {\n      case PipelineStatisticName::VertexShaderInvocations:\n        o << \"PipelineStatisticName::VertexShaderInvocations\";\n        break;\n      case PipelineStatisticName::ClipperInvocations:\n        o << \"PipelineStatisticName::ClipperInvocations\";\n        break;\n      case PipelineStatisticName::ClipperPrimitivesOut:\n        o << \"PipelineStatisticName::ClipperPrimitivesOut\";\n        break;\n      case PipelineStatisticName::FragmentShaderInvocations:\n        o << \"PipelineStatisticName::FragmentShaderInvocations\";\n        break;\n      case PipelineStatisticName::ComputeShaderInvocations:\n        o << \"PipelineStatisticName::ComputeShaderInvocations\";\n        break;\n          default:\n            o << \"PipelineStatisticName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PipelineStatisticName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PowerPreference value) {\n      switch (value) {\n      case PowerPreference::Undefined:\n        o << \"PowerPreference::Undefined\";\n        break;\n      case PowerPreference::LowPower:\n        o << \"PowerPreference::LowPower\";\n        break;\n      case PowerPreference::HighPerformance:\n        o << \"PowerPreference::HighPerformance\";\n        break;\n          default:\n            o << \"PowerPreference::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PowerPreference>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PresentMode value) {\n      switch (value) {\n      case PresentMode::Immediate:\n        o << \"PresentMode::Immediate\";\n        break;\n      case PresentMode::Mailbox:\n        o << \"PresentMode::Mailbox\";\n        break;\n      case PresentMode::Fifo:\n        o << \"PresentMode::Fifo\";\n        break;\n          default:\n            o << \"PresentMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PresentMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PrimitiveTopology value) {\n      switch (value) {\n      case PrimitiveTopology::PointList:\n        o << \"PrimitiveTopology::PointList\";\n        break;\n      case PrimitiveTopology::LineList:\n        o << \"PrimitiveTopology::LineList\";\n        break;\n      case PrimitiveTopology::LineStrip:\n        o << \"PrimitiveTopology::LineStrip\";\n        break;\n      case PrimitiveTopology::TriangleList:\n        o << \"PrimitiveTopology::TriangleList\";\n        break;\n      case PrimitiveTopology::TriangleStrip:\n        o << \"PrimitiveTopology::TriangleStrip\";\n        break;\n          default:\n            o << \"PrimitiveTopology::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PrimitiveTopology>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueryType value) {\n      switch (value) {\n      case QueryType::Occlusion:\n        o << \"QueryType::Occlusion\";\n        break;\n      case QueryType::PipelineStatistics:\n        o << \"QueryType::PipelineStatistics\";\n        break;\n      case QueryType::Timestamp:\n        o << \"QueryType::Timestamp\";\n        break;\n          default:\n            o << \"QueryType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueryType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueueWorkDoneStatus value) {\n      switch (value) {\n      case QueueWorkDoneStatus::Success:\n        o << \"QueueWorkDoneStatus::Success\";\n        break;\n      case QueueWorkDoneStatus::Error:\n        o << \"QueueWorkDoneStatus::Error\";\n        break;\n      case QueueWorkDoneStatus::Unknown:\n        o << \"QueueWorkDoneStatus::Unknown\";\n        break;\n      case QueueWorkDoneStatus::DeviceLost:\n        o << \"QueueWorkDoneStatus::DeviceLost\";\n        break;\n          default:\n            o << \"QueueWorkDoneStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueueWorkDoneStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RenderPassTimestampLocation value) {\n      switch (value) {\n      case RenderPassTimestampLocation::Beginning:\n        o << \"RenderPassTimestampLocation::Beginning\";\n        break;\n      case RenderPassTimestampLocation::End:\n        o << \"RenderPassTimestampLocation::End\";\n        break;\n          default:\n            o << \"RenderPassTimestampLocation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RenderPassTimestampLocation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestAdapterStatus value) {\n      switch (value) {\n      case RequestAdapterStatus::Success:\n        o << \"RequestAdapterStatus::Success\";\n        break;\n      case RequestAdapterStatus::Unavailable:\n        o << \"RequestAdapterStatus::Unavailable\";\n        break;\n      case RequestAdapterStatus::Error:\n        o << \"RequestAdapterStatus::Error\";\n        break;\n      case RequestAdapterStatus::Unknown:\n        o << \"RequestAdapterStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestAdapterStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestAdapterStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestDeviceStatus value) {\n      switch (value) {\n      case RequestDeviceStatus::Success:\n        o << \"RequestDeviceStatus::Success\";\n        break;\n      case RequestDeviceStatus::Error:\n        o << \"RequestDeviceStatus::Error\";\n        break;\n      case RequestDeviceStatus::Unknown:\n        o << \"RequestDeviceStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestDeviceStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestDeviceStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SType value) {\n      switch (value) {\n      case SType::Invalid:\n        o << \"SType::Invalid\";\n        break;\n      case SType::SurfaceDescriptorFromMetalLayer:\n        o << \"SType::SurfaceDescriptorFromMetalLayer\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsHWND:\n        o << \"SType::SurfaceDescriptorFromWindowsHWND\";\n        break;\n      case SType::SurfaceDescriptorFromXlibWindow:\n        o << \"SType::SurfaceDescriptorFromXlibWindow\";\n        break;\n      case SType::SurfaceDescriptorFromCanvasHTMLSelector:\n        o << \"SType::SurfaceDescriptorFromCanvasHTMLSelector\";\n        break;\n      case SType::ShaderModuleSPIRVDescriptor:\n        o << \"SType::ShaderModuleSPIRVDescriptor\";\n        break;\n      case SType::ShaderModuleWGSLDescriptor:\n        o << \"SType::ShaderModuleWGSLDescriptor\";\n        break;\n      case SType::PrimitiveDepthClipControl:\n        o << \"SType::PrimitiveDepthClipControl\";\n        break;\n      case SType::SurfaceDescriptorFromWaylandSurface:\n        o << \"SType::SurfaceDescriptorFromWaylandSurface\";\n        break;\n      case SType::SurfaceDescriptorFromAndroidNativeWindow:\n        o << \"SType::SurfaceDescriptorFromAndroidNativeWindow\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsCoreWindow:\n        o << \"SType::SurfaceDescriptorFromWindowsCoreWindow\";\n        break;\n      case SType::ExternalTextureBindingEntry:\n        o << \"SType::ExternalTextureBindingEntry\";\n        break;\n      case SType::ExternalTextureBindingLayout:\n        o << \"SType::ExternalTextureBindingLayout\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n        o << \"SType::SurfaceDescriptorFromWindowsSwapChainPanel\";\n        break;\n      case SType::RenderPassDescriptorMaxDrawCount:\n        o << \"SType::RenderPassDescriptorMaxDrawCount\";\n        break;\n      case SType::DawnTextureInternalUsageDescriptor:\n        o << \"SType::DawnTextureInternalUsageDescriptor\";\n        break;\n      case SType::DawnTogglesDeviceDescriptor:\n        o << \"SType::DawnTogglesDeviceDescriptor\";\n        break;\n      case SType::DawnEncoderInternalUsageDescriptor:\n        o << \"SType::DawnEncoderInternalUsageDescriptor\";\n        break;\n      case SType::DawnInstanceDescriptor:\n        o << \"SType::DawnInstanceDescriptor\";\n        break;\n      case SType::DawnCacheDeviceDescriptor:\n        o << \"SType::DawnCacheDeviceDescriptor\";\n        break;\n      case SType::DawnAdapterPropertiesPowerPreference:\n        o << \"SType::DawnAdapterPropertiesPowerPreference\";\n        break;\n      case SType::DawnBufferDescriptorErrorInfoFromWireClient:\n        o << \"SType::DawnBufferDescriptorErrorInfoFromWireClient\";\n        break;\n          default:\n            o << \"SType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SamplerBindingType value) {\n      switch (value) {\n      case SamplerBindingType::Undefined:\n        o << \"SamplerBindingType::Undefined\";\n        break;\n      case SamplerBindingType::Filtering:\n        o << \"SamplerBindingType::Filtering\";\n        break;\n      case SamplerBindingType::NonFiltering:\n        o << \"SamplerBindingType::NonFiltering\";\n        break;\n      case SamplerBindingType::Comparison:\n        o << \"SamplerBindingType::Comparison\";\n        break;\n          default:\n            o << \"SamplerBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SamplerBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StencilOperation value) {\n      switch (value) {\n      case StencilOperation::Keep:\n        o << \"StencilOperation::Keep\";\n        break;\n      case StencilOperation::Zero:\n        o << \"StencilOperation::Zero\";\n        break;\n      case StencilOperation::Replace:\n        o << \"StencilOperation::Replace\";\n        break;\n      case StencilOperation::Invert:\n        o << \"StencilOperation::Invert\";\n        break;\n      case StencilOperation::IncrementClamp:\n        o << \"StencilOperation::IncrementClamp\";\n        break;\n      case StencilOperation::DecrementClamp:\n        o << \"StencilOperation::DecrementClamp\";\n        break;\n      case StencilOperation::IncrementWrap:\n        o << \"StencilOperation::IncrementWrap\";\n        break;\n      case StencilOperation::DecrementWrap:\n        o << \"StencilOperation::DecrementWrap\";\n        break;\n          default:\n            o << \"StencilOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StencilOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StorageTextureAccess value) {\n      switch (value) {\n      case StorageTextureAccess::Undefined:\n        o << \"StorageTextureAccess::Undefined\";\n        break;\n      case StorageTextureAccess::WriteOnly:\n        o << \"StorageTextureAccess::WriteOnly\";\n        break;\n          default:\n            o << \"StorageTextureAccess::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StorageTextureAccess>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StoreOp value) {\n      switch (value) {\n      case StoreOp::Undefined:\n        o << \"StoreOp::Undefined\";\n        break;\n      case StoreOp::Store:\n        o << \"StoreOp::Store\";\n        break;\n      case StoreOp::Discard:\n        o << \"StoreOp::Discard\";\n        break;\n          default:\n            o << \"StoreOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StoreOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureAspect value) {\n      switch (value) {\n      case TextureAspect::All:\n        o << \"TextureAspect::All\";\n        break;\n      case TextureAspect::StencilOnly:\n        o << \"TextureAspect::StencilOnly\";\n        break;\n      case TextureAspect::DepthOnly:\n        o << \"TextureAspect::DepthOnly\";\n        break;\n      case TextureAspect::Plane0Only:\n        o << \"TextureAspect::Plane0Only\";\n        break;\n      case TextureAspect::Plane1Only:\n        o << \"TextureAspect::Plane1Only\";\n        break;\n          default:\n            o << \"TextureAspect::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureAspect>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureComponentType value) {\n      switch (value) {\n      case TextureComponentType::Float:\n        o << \"TextureComponentType::Float\";\n        break;\n      case TextureComponentType::Sint:\n        o << \"TextureComponentType::Sint\";\n        break;\n      case TextureComponentType::Uint:\n        o << \"TextureComponentType::Uint\";\n        break;\n      case TextureComponentType::DepthComparison:\n        o << \"TextureComponentType::DepthComparison\";\n        break;\n          default:\n            o << \"TextureComponentType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureComponentType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureDimension value) {\n      switch (value) {\n      case TextureDimension::e1D:\n        o << \"TextureDimension::e1D\";\n        break;\n      case TextureDimension::e2D:\n        o << \"TextureDimension::e2D\";\n        break;\n      case TextureDimension::e3D:\n        o << \"TextureDimension::e3D\";\n        break;\n          default:\n            o << \"TextureDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureFormat value) {\n      switch (value) {\n      case TextureFormat::Undefined:\n        o << \"TextureFormat::Undefined\";\n        break;\n      case TextureFormat::R8Unorm:\n        o << \"TextureFormat::R8Unorm\";\n        break;\n      case TextureFormat::R8Snorm:\n        o << \"TextureFormat::R8Snorm\";\n        break;\n      case TextureFormat::R8Uint:\n        o << \"TextureFormat::R8Uint\";\n        break;\n      case TextureFormat::R8Sint:\n        o << \"TextureFormat::R8Sint\";\n        break;\n      case TextureFormat::R16Uint:\n        o << \"TextureFormat::R16Uint\";\n        break;\n      case TextureFormat::R16Sint:\n        o << \"TextureFormat::R16Sint\";\n        break;\n      case TextureFormat::R16Float:\n        o << \"TextureFormat::R16Float\";\n        break;\n      case TextureFormat::RG8Unorm:\n        o << \"TextureFormat::RG8Unorm\";\n        break;\n      case TextureFormat::RG8Snorm:\n        o << \"TextureFormat::RG8Snorm\";\n        break;\n      case TextureFormat::RG8Uint:\n        o << \"TextureFormat::RG8Uint\";\n        break;\n      case TextureFormat::RG8Sint:\n        o << \"TextureFormat::RG8Sint\";\n        break;\n      case TextureFormat::R32Float:\n        o << \"TextureFormat::R32Float\";\n        break;\n      case TextureFormat::R32Uint:\n        o << \"TextureFormat::R32Uint\";\n        break;\n      case TextureFormat::R32Sint:\n        o << \"TextureFormat::R32Sint\";\n        break;\n      case TextureFormat::RG16Uint:\n        o << \"TextureFormat::RG16Uint\";\n        break;\n      case TextureFormat::RG16Sint:\n        o << \"TextureFormat::RG16Sint\";\n        break;\n      case TextureFormat::RG16Float:\n        o << \"TextureFormat::RG16Float\";\n        break;\n      case TextureFormat::RGBA8Unorm:\n        o << \"TextureFormat::RGBA8Unorm\";\n        break;\n      case TextureFormat::RGBA8UnormSrgb:\n        o << \"TextureFormat::RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::RGBA8Snorm:\n        o << \"TextureFormat::RGBA8Snorm\";\n        break;\n      case TextureFormat::RGBA8Uint:\n        o << \"TextureFormat::RGBA8Uint\";\n        break;\n      case TextureFormat::RGBA8Sint:\n        o << \"TextureFormat::RGBA8Sint\";\n        break;\n      case TextureFormat::BGRA8Unorm:\n        o << \"TextureFormat::BGRA8Unorm\";\n        break;\n      case TextureFormat::BGRA8UnormSrgb:\n        o << \"TextureFormat::BGRA8UnormSrgb\";\n        break;\n      case TextureFormat::RGB10A2Unorm:\n        o << \"TextureFormat::RGB10A2Unorm\";\n        break;\n      case TextureFormat::RG11B10Ufloat:\n        o << \"TextureFormat::RG11B10Ufloat\";\n        break;\n      case TextureFormat::RGB9E5Ufloat:\n        o << \"TextureFormat::RGB9E5Ufloat\";\n        break;\n      case TextureFormat::RG32Float:\n        o << \"TextureFormat::RG32Float\";\n        break;\n      case TextureFormat::RG32Uint:\n        o << \"TextureFormat::RG32Uint\";\n        break;\n      case TextureFormat::RG32Sint:\n        o << \"TextureFormat::RG32Sint\";\n        break;\n      case TextureFormat::RGBA16Uint:\n        o << \"TextureFormat::RGBA16Uint\";\n        break;\n      case TextureFormat::RGBA16Sint:\n        o << \"TextureFormat::RGBA16Sint\";\n        break;\n      case TextureFormat::RGBA16Float:\n        o << \"TextureFormat::RGBA16Float\";\n        break;\n      case TextureFormat::RGBA32Float:\n        o << \"TextureFormat::RGBA32Float\";\n        break;\n      case TextureFormat::RGBA32Uint:\n        o << \"TextureFormat::RGBA32Uint\";\n        break;\n      case TextureFormat::RGBA32Sint:\n        o << \"TextureFormat::RGBA32Sint\";\n        break;\n      case TextureFormat::Stencil8:\n        o << \"TextureFormat::Stencil8\";\n        break;\n      case TextureFormat::Depth16Unorm:\n        o << \"TextureFormat::Depth16Unorm\";\n        break;\n      case TextureFormat::Depth24Plus:\n        o << \"TextureFormat::Depth24Plus\";\n        break;\n      case TextureFormat::Depth24PlusStencil8:\n        o << \"TextureFormat::Depth24PlusStencil8\";\n        break;\n      case TextureFormat::Depth32Float:\n        o << \"TextureFormat::Depth32Float\";\n        break;\n      case TextureFormat::Depth32FloatStencil8:\n        o << \"TextureFormat::Depth32FloatStencil8\";\n        break;\n      case TextureFormat::BC1RGBAUnorm:\n        o << \"TextureFormat::BC1RGBAUnorm\";\n        break;\n      case TextureFormat::BC1RGBAUnormSrgb:\n        o << \"TextureFormat::BC1RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC2RGBAUnorm:\n        o << \"TextureFormat::BC2RGBAUnorm\";\n        break;\n      case TextureFormat::BC2RGBAUnormSrgb:\n        o << \"TextureFormat::BC2RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC3RGBAUnorm:\n        o << \"TextureFormat::BC3RGBAUnorm\";\n        break;\n      case TextureFormat::BC3RGBAUnormSrgb:\n        o << \"TextureFormat::BC3RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC4RUnorm:\n        o << \"TextureFormat::BC4RUnorm\";\n        break;\n      case TextureFormat::BC4RSnorm:\n        o << \"TextureFormat::BC4RSnorm\";\n        break;\n      case TextureFormat::BC5RGUnorm:\n        o << \"TextureFormat::BC5RGUnorm\";\n        break;\n      case TextureFormat::BC5RGSnorm:\n        o << \"TextureFormat::BC5RGSnorm\";\n        break;\n      case TextureFormat::BC6HRGBUfloat:\n        o << \"TextureFormat::BC6HRGBUfloat\";\n        break;\n      case TextureFormat::BC6HRGBFloat:\n        o << \"TextureFormat::BC6HRGBFloat\";\n        break;\n      case TextureFormat::BC7RGBAUnorm:\n        o << \"TextureFormat::BC7RGBAUnorm\";\n        break;\n      case TextureFormat::BC7RGBAUnormSrgb:\n        o << \"TextureFormat::BC7RGBAUnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8Unorm:\n        o << \"TextureFormat::ETC2RGB8Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8A1Unorm:\n        o << \"TextureFormat::ETC2RGB8A1Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8A1UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8A1UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGBA8Unorm:\n        o << \"TextureFormat::ETC2RGBA8Unorm\";\n        break;\n      case TextureFormat::ETC2RGBA8UnormSrgb:\n        o << \"TextureFormat::ETC2RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::EACR11Unorm:\n        o << \"TextureFormat::EACR11Unorm\";\n        break;\n      case TextureFormat::EACR11Snorm:\n        o << \"TextureFormat::EACR11Snorm\";\n        break;\n      case TextureFormat::EACRG11Unorm:\n        o << \"TextureFormat::EACRG11Unorm\";\n        break;\n      case TextureFormat::EACRG11Snorm:\n        o << \"TextureFormat::EACRG11Snorm\";\n        break;\n      case TextureFormat::ASTC4x4Unorm:\n        o << \"TextureFormat::ASTC4x4Unorm\";\n        break;\n      case TextureFormat::ASTC4x4UnormSrgb:\n        o << \"TextureFormat::ASTC4x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x4Unorm:\n        o << \"TextureFormat::ASTC5x4Unorm\";\n        break;\n      case TextureFormat::ASTC5x4UnormSrgb:\n        o << \"TextureFormat::ASTC5x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x5Unorm:\n        o << \"TextureFormat::ASTC5x5Unorm\";\n        break;\n      case TextureFormat::ASTC5x5UnormSrgb:\n        o << \"TextureFormat::ASTC5x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x5Unorm:\n        o << \"TextureFormat::ASTC6x5Unorm\";\n        break;\n      case TextureFormat::ASTC6x5UnormSrgb:\n        o << \"TextureFormat::ASTC6x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x6Unorm:\n        o << \"TextureFormat::ASTC6x6Unorm\";\n        break;\n      case TextureFormat::ASTC6x6UnormSrgb:\n        o << \"TextureFormat::ASTC6x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x5Unorm:\n        o << \"TextureFormat::ASTC8x5Unorm\";\n        break;\n      case TextureFormat::ASTC8x5UnormSrgb:\n        o << \"TextureFormat::ASTC8x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x6Unorm:\n        o << \"TextureFormat::ASTC8x6Unorm\";\n        break;\n      case TextureFormat::ASTC8x6UnormSrgb:\n        o << \"TextureFormat::ASTC8x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x8Unorm:\n        o << \"TextureFormat::ASTC8x8Unorm\";\n        break;\n      case TextureFormat::ASTC8x8UnormSrgb:\n        o << \"TextureFormat::ASTC8x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x5Unorm:\n        o << \"TextureFormat::ASTC10x5Unorm\";\n        break;\n      case TextureFormat::ASTC10x5UnormSrgb:\n        o << \"TextureFormat::ASTC10x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x6Unorm:\n        o << \"TextureFormat::ASTC10x6Unorm\";\n        break;\n      case TextureFormat::ASTC10x6UnormSrgb:\n        o << \"TextureFormat::ASTC10x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x8Unorm:\n        o << \"TextureFormat::ASTC10x8Unorm\";\n        break;\n      case TextureFormat::ASTC10x8UnormSrgb:\n        o << \"TextureFormat::ASTC10x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x10Unorm:\n        o << \"TextureFormat::ASTC10x10Unorm\";\n        break;\n      case TextureFormat::ASTC10x10UnormSrgb:\n        o << \"TextureFormat::ASTC10x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x10Unorm:\n        o << \"TextureFormat::ASTC12x10Unorm\";\n        break;\n      case TextureFormat::ASTC12x10UnormSrgb:\n        o << \"TextureFormat::ASTC12x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x12Unorm:\n        o << \"TextureFormat::ASTC12x12Unorm\";\n        break;\n      case TextureFormat::ASTC12x12UnormSrgb:\n        o << \"TextureFormat::ASTC12x12UnormSrgb\";\n        break;\n      case TextureFormat::R8BG8Biplanar420Unorm:\n        o << \"TextureFormat::R8BG8Biplanar420Unorm\";\n        break;\n          default:\n            o << \"TextureFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureSampleType value) {\n      switch (value) {\n      case TextureSampleType::Undefined:\n        o << \"TextureSampleType::Undefined\";\n        break;\n      case TextureSampleType::Float:\n        o << \"TextureSampleType::Float\";\n        break;\n      case TextureSampleType::UnfilterableFloat:\n        o << \"TextureSampleType::UnfilterableFloat\";\n        break;\n      case TextureSampleType::Depth:\n        o << \"TextureSampleType::Depth\";\n        break;\n      case TextureSampleType::Sint:\n        o << \"TextureSampleType::Sint\";\n        break;\n      case TextureSampleType::Uint:\n        o << \"TextureSampleType::Uint\";\n        break;\n          default:\n            o << \"TextureSampleType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureSampleType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureViewDimension value) {\n      switch (value) {\n      case TextureViewDimension::Undefined:\n        o << \"TextureViewDimension::Undefined\";\n        break;\n      case TextureViewDimension::e1D:\n        o << \"TextureViewDimension::e1D\";\n        break;\n      case TextureViewDimension::e2D:\n        o << \"TextureViewDimension::e2D\";\n        break;\n      case TextureViewDimension::e2DArray:\n        o << \"TextureViewDimension::e2DArray\";\n        break;\n      case TextureViewDimension::Cube:\n        o << \"TextureViewDimension::Cube\";\n        break;\n      case TextureViewDimension::CubeArray:\n        o << \"TextureViewDimension::CubeArray\";\n        break;\n      case TextureViewDimension::e3D:\n        o << \"TextureViewDimension::e3D\";\n        break;\n          default:\n            o << \"TextureViewDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureViewDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexFormat value) {\n      switch (value) {\n      case VertexFormat::Undefined:\n        o << \"VertexFormat::Undefined\";\n        break;\n      case VertexFormat::Uint8x2:\n        o << \"VertexFormat::Uint8x2\";\n        break;\n      case VertexFormat::Uint8x4:\n        o << \"VertexFormat::Uint8x4\";\n        break;\n      case VertexFormat::Sint8x2:\n        o << \"VertexFormat::Sint8x2\";\n        break;\n      case VertexFormat::Sint8x4:\n        o << \"VertexFormat::Sint8x4\";\n        break;\n      case VertexFormat::Unorm8x2:\n        o << \"VertexFormat::Unorm8x2\";\n        break;\n      case VertexFormat::Unorm8x4:\n        o << \"VertexFormat::Unorm8x4\";\n        break;\n      case VertexFormat::Snorm8x2:\n        o << \"VertexFormat::Snorm8x2\";\n        break;\n      case VertexFormat::Snorm8x4:\n        o << \"VertexFormat::Snorm8x4\";\n        break;\n      case VertexFormat::Uint16x2:\n        o << \"VertexFormat::Uint16x2\";\n        break;\n      case VertexFormat::Uint16x4:\n        o << \"VertexFormat::Uint16x4\";\n        break;\n      case VertexFormat::Sint16x2:\n        o << \"VertexFormat::Sint16x2\";\n        break;\n      case VertexFormat::Sint16x4:\n        o << \"VertexFormat::Sint16x4\";\n        break;\n      case VertexFormat::Unorm16x2:\n        o << \"VertexFormat::Unorm16x2\";\n        break;\n      case VertexFormat::Unorm16x4:\n        o << \"VertexFormat::Unorm16x4\";\n        break;\n      case VertexFormat::Snorm16x2:\n        o << \"VertexFormat::Snorm16x2\";\n        break;\n      case VertexFormat::Snorm16x4:\n        o << \"VertexFormat::Snorm16x4\";\n        break;\n      case VertexFormat::Float16x2:\n        o << \"VertexFormat::Float16x2\";\n        break;\n      case VertexFormat::Float16x4:\n        o << \"VertexFormat::Float16x4\";\n        break;\n      case VertexFormat::Float32:\n        o << \"VertexFormat::Float32\";\n        break;\n      case VertexFormat::Float32x2:\n        o << \"VertexFormat::Float32x2\";\n        break;\n      case VertexFormat::Float32x3:\n        o << \"VertexFormat::Float32x3\";\n        break;\n      case VertexFormat::Float32x4:\n        o << \"VertexFormat::Float32x4\";\n        break;\n      case VertexFormat::Uint32:\n        o << \"VertexFormat::Uint32\";\n        break;\n      case VertexFormat::Uint32x2:\n        o << \"VertexFormat::Uint32x2\";\n        break;\n      case VertexFormat::Uint32x3:\n        o << \"VertexFormat::Uint32x3\";\n        break;\n      case VertexFormat::Uint32x4:\n        o << \"VertexFormat::Uint32x4\";\n        break;\n      case VertexFormat::Sint32:\n        o << \"VertexFormat::Sint32\";\n        break;\n      case VertexFormat::Sint32x2:\n        o << \"VertexFormat::Sint32x2\";\n        break;\n      case VertexFormat::Sint32x3:\n        o << \"VertexFormat::Sint32x3\";\n        break;\n      case VertexFormat::Sint32x4:\n        o << \"VertexFormat::Sint32x4\";\n        break;\n          default:\n            o << \"VertexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexStepMode value) {\n      switch (value) {\n      case VertexStepMode::Vertex:\n        o << \"VertexStepMode::Vertex\";\n        break;\n      case VertexStepMode::Instance:\n        o << \"VertexStepMode::Instance\";\n        break;\n      case VertexStepMode::VertexBufferNotUsed:\n        o << \"VertexStepMode::VertexBufferNotUsed\";\n        break;\n          default:\n            o << \"VertexStepMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexStepMode>::type>(value);\n      }\n      return o;\n  }\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferUsage value) {\n    o << \"BufferUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & BufferUsage::MapRead) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapRead\";\n    value &= ~BufferUsage::MapRead;\n  }\n  if (value & BufferUsage::MapWrite) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapWrite\";\n    value &= ~BufferUsage::MapWrite;\n  }\n  if (value & BufferUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~BufferUsage::CopySrc;\n  }\n  if (value & BufferUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~BufferUsage::CopyDst;\n  }\n  if (value & BufferUsage::Index) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Index\";\n    value &= ~BufferUsage::Index;\n  }\n  if (value & BufferUsage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~BufferUsage::Vertex;\n  }\n  if (value & BufferUsage::Uniform) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Uniform\";\n    value &= ~BufferUsage::Uniform;\n  }\n  if (value & BufferUsage::Storage) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Storage\";\n    value &= ~BufferUsage::Storage;\n  }\n  if (value & BufferUsage::Indirect) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Indirect\";\n    value &= ~BufferUsage::Indirect;\n  }\n  if (value & BufferUsage::QueryResolve) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"QueryResolve\";\n    value &= ~BufferUsage::QueryResolve;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ColorWriteMask value) {\n    o << \"ColorWriteMask::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ColorWriteMask::Red) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Red\";\n    value &= ~ColorWriteMask::Red;\n  }\n  if (value & ColorWriteMask::Green) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Green\";\n    value &= ~ColorWriteMask::Green;\n  }\n  if (value & ColorWriteMask::Blue) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Blue\";\n    value &= ~ColorWriteMask::Blue;\n  }\n  if (value & ColorWriteMask::Alpha) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Alpha\";\n    value &= ~ColorWriteMask::Alpha;\n  }\n  if (value & ColorWriteMask::All) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"All\";\n    value &= ~ColorWriteMask::All;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ColorWriteMask>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MapMode value) {\n    o << \"MapMode::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & MapMode::Read) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Read\";\n    value &= ~MapMode::Read;\n  }\n  if (value & MapMode::Write) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Write\";\n    value &= ~MapMode::Write;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MapMode>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ShaderStage value) {\n    o << \"ShaderStage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ShaderStage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~ShaderStage::Vertex;\n  }\n  if (value & ShaderStage::Fragment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Fragment\";\n    value &= ~ShaderStage::Fragment;\n  }\n  if (value & ShaderStage::Compute) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Compute\";\n    value &= ~ShaderStage::Compute;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ShaderStage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureUsage value) {\n    o << \"TextureUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & TextureUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~TextureUsage::CopySrc;\n  }\n  if (value & TextureUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~TextureUsage::CopyDst;\n  }\n  if (value & TextureUsage::TextureBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"TextureBinding\";\n    value &= ~TextureUsage::TextureBinding;\n  }\n  if (value & TextureUsage::StorageBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"StorageBinding\";\n    value &= ~TextureUsage::StorageBinding;\n  }\n  if (value & TextureUsage::RenderAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"RenderAttachment\";\n    value &= ~TextureUsage::RenderAttachment;\n  }\n  if (value & TextureUsage::Present) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Present\";\n    value &= ~TextureUsage::Present;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n\n}  // namespace wgpu\n\n#endif // WEBGPU_CPP_PRINT_H_\n", "./include/dawn/EnumClassBitmasks.h": "// Copyright 2017 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_ENUMCLASSBITMASKS_H_\n#define INCLUDE_DAWN_ENUMCLASSBITMASKS_H_\n\n#include <type_traits>\n\n// The operators in dawn:: namespace need be introduced into other namespaces with\n// using-declarations for C++ Argument Dependent Lookup to work.\n#define DAWN_IMPORT_BITMASK_OPERATORS \\\n    using dawn::operator|;            \\\n    using dawn::operator&;            \\\n    using dawn::operator^;            \\\n    using dawn::operator~;            \\\n    using dawn::operator&=;           \\\n    using dawn::operator|=;           \\\n    using dawn::operator^=;           \\\n    using dawn::HasZeroOrOneBits;\n\nnamespace dawn {\n\ntemplate <typename T>\nstruct IsDawnBitmask {\n    static constexpr bool enable = false;\n};\n\ntemplate <typename T, typename Enable = void>\nstruct LowerBitmask {\n    static constexpr bool enable = false;\n};\n\ntemplate <typename T>\nstruct LowerBitmask<T, typename std::enable_if<IsDawnBitmask<T>::enable>::type> {\n    static constexpr bool enable = true;\n    using type = T;\n    constexpr static T Lower(T t) { return t; }\n};\n\ntemplate <typename T>\nstruct BoolConvertible {\n    using Integral = typename std::underlying_type<T>::type;\n\n    // NOLINTNEXTLINE(runtime/explicit)\n    constexpr BoolConvertible(Integral value) : value(value) {}\n    constexpr operator bool() const { return value != 0; }\n    constexpr operator T() const { return static_cast<T>(value); }\n\n    Integral value;\n};\n\ntemplate <typename T>\nstruct LowerBitmask<BoolConvertible<T>> {\n    static constexpr bool enable = true;\n    using type = T;\n    static constexpr type Lower(BoolConvertible<T> t) { return t; }\n};\n\ntemplate <\n    typename T1,\n    typename T2,\n    typename = typename std::enable_if<LowerBitmask<T1>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator|(T1 left, T2 right) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return static_cast<Integral>(LowerBitmask<T1>::Lower(left)) |\n           static_cast<Integral>(LowerBitmask<T2>::Lower(right));\n}\n\ntemplate <\n    typename T1,\n    typename T2,\n    typename = typename std::enable_if<LowerBitmask<T1>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator&(T1 left, T2 right) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return static_cast<Integral>(LowerBitmask<T1>::Lower(left)) &\n           static_cast<Integral>(LowerBitmask<T2>::Lower(right));\n}\n\ntemplate <\n    typename T1,\n    typename T2,\n    typename = typename std::enable_if<LowerBitmask<T1>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator^(T1 left, T2 right) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return static_cast<Integral>(LowerBitmask<T1>::Lower(left)) ^\n           static_cast<Integral>(LowerBitmask<T2>::Lower(right));\n}\n\ntemplate <typename T1>\nconstexpr BoolConvertible<typename LowerBitmask<T1>::type> operator~(T1 t) {\n    using T = typename LowerBitmask<T1>::type;\n    using Integral = typename std::underlying_type<T>::type;\n    return ~static_cast<Integral>(LowerBitmask<T1>::Lower(t));\n}\n\ntemplate <\n    typename T,\n    typename T2,\n    typename = typename std::enable_if<IsDawnBitmask<T>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr T& operator&=(T& l, T2 right) {\n    T r = LowerBitmask<T2>::Lower(right);\n    l = l & r;\n    return l;\n}\n\ntemplate <\n    typename T,\n    typename T2,\n    typename = typename std::enable_if<IsDawnBitmask<T>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr T& operator|=(T& l, T2 right) {\n    T r = LowerBitmask<T2>::Lower(right);\n    l = l | r;\n    return l;\n}\n\ntemplate <\n    typename T,\n    typename T2,\n    typename = typename std::enable_if<IsDawnBitmask<T>::enable && LowerBitmask<T2>::enable>::type>\nconstexpr T& operator^=(T& l, T2 right) {\n    T r = LowerBitmask<T2>::Lower(right);\n    l = l ^ r;\n    return l;\n}\n\ntemplate <typename T>\nconstexpr bool HasZeroOrOneBits(T value) {\n    using Integral = typename std::underlying_type<T>::type;\n    return (static_cast<Integral>(value) & (static_cast<Integral>(value) - 1)) == 0;\n}\n\n}  // namespace dawn\n\n#endif  // INCLUDE_DAWN_ENUMCLASSBITMASKS_H_\n", "./include/dawn/webgpu.h": "// BSD 3-Clause License\n//\n// Copyright (c) 2019, \"WebGPU native\" developers\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n#ifndef WEBGPU_H_\n#define WEBGPU_H_\n\n#if defined(WGPU_SHARED_LIBRARY)\n#    if defined(_WIN32)\n#        if defined(WGPU_IMPLEMENTATION)\n#            define WGPU_EXPORT __declspec(dllexport)\n#        else\n#            define WGPU_EXPORT __declspec(dllimport)\n#        endif\n#    else  // defined(_WIN32)\n#        if defined(WGPU_IMPLEMENTATION)\n#            define WGPU_EXPORT __attribute__((visibility(\"default\")))\n#        else\n#            define WGPU_EXPORT\n#        endif\n#    endif  // defined(_WIN32)\n#else       // defined(WGPU_SHARED_LIBRARY)\n#    define WGPU_EXPORT\n#endif  // defined(WGPU_SHARED_LIBRARY)\n\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define WGPU_ARRAY_LAYER_COUNT_UNDEFINED (0xffffffffUL)\n#define WGPU_COPY_STRIDE_UNDEFINED (0xffffffffUL)\n#define WGPU_LIMIT_U32_UNDEFINED (0xffffffffUL)\n#define WGPU_LIMIT_U64_UNDEFINED (0xffffffffffffffffULL)\n#define WGPU_MIP_LEVEL_COUNT_UNDEFINED (0xffffffffUL)\n#define WGPU_STRIDE_UNDEFINED (0xffffffffUL)\n#define WGPU_WHOLE_MAP_SIZE SIZE_MAX\n#define WGPU_WHOLE_SIZE (0xffffffffffffffffULL)\n\ntypedef uint32_t WGPUFlags;\n\ntypedef struct WGPUAdapterImpl* WGPUAdapter;\ntypedef struct WGPUBindGroupImpl* WGPUBindGroup;\ntypedef struct WGPUBindGroupLayoutImpl* WGPUBindGroupLayout;\ntypedef struct WGPUBufferImpl* WGPUBuffer;\ntypedef struct WGPUCommandBufferImpl* WGPUCommandBuffer;\ntypedef struct WGPUCommandEncoderImpl* WGPUCommandEncoder;\ntypedef struct WGPUComputePassEncoderImpl* WGPUComputePassEncoder;\ntypedef struct WGPUComputePipelineImpl* WGPUComputePipeline;\ntypedef struct WGPUDeviceImpl* WGPUDevice;\ntypedef struct WGPUExternalTextureImpl* WGPUExternalTexture;\ntypedef struct WGPUInstanceImpl* WGPUInstance;\ntypedef struct WGPUPipelineLayoutImpl* WGPUPipelineLayout;\ntypedef struct WGPUQuerySetImpl* WGPUQuerySet;\ntypedef struct WGPUQueueImpl* WGPUQueue;\ntypedef struct WGPURenderBundleImpl* WGPURenderBundle;\ntypedef struct WGPURenderBundleEncoderImpl* WGPURenderBundleEncoder;\ntypedef struct WGPURenderPassEncoderImpl* WGPURenderPassEncoder;\ntypedef struct WGPURenderPipelineImpl* WGPURenderPipeline;\ntypedef struct WGPUSamplerImpl* WGPUSampler;\ntypedef struct WGPUShaderModuleImpl* WGPUShaderModule;\ntypedef struct WGPUSurfaceImpl* WGPUSurface;\ntypedef struct WGPUSwapChainImpl* WGPUSwapChain;\ntypedef struct WGPUTextureImpl* WGPUTexture;\ntypedef struct WGPUTextureViewImpl* WGPUTextureView;\n\ntypedef enum WGPUAdapterType {\n    WGPUAdapterType_DiscreteGPU = 0x00000000,\n    WGPUAdapterType_IntegratedGPU = 0x00000001,\n    WGPUAdapterType_CPU = 0x00000002,\n    WGPUAdapterType_Unknown = 0x00000003,\n    WGPUAdapterType_Force32 = 0x7FFFFFFF\n} WGPUAdapterType;\n\ntypedef enum WGPUAddressMode {\n    WGPUAddressMode_Repeat = 0x00000000,\n    WGPUAddressMode_MirrorRepeat = 0x00000001,\n    WGPUAddressMode_ClampToEdge = 0x00000002,\n    WGPUAddressMode_Force32 = 0x7FFFFFFF\n} WGPUAddressMode;\n\ntypedef enum WGPUAlphaMode {\n    WGPUAlphaMode_Premultiplied = 0x00000000,\n    WGPUAlphaMode_Unpremultiplied = 0x00000001,\n    WGPUAlphaMode_Opaque = 0x00000002,\n    WGPUAlphaMode_Force32 = 0x7FFFFFFF\n} WGPUAlphaMode;\n\ntypedef enum WGPUBackendType {\n    WGPUBackendType_Null = 0x00000000,\n    WGPUBackendType_WebGPU = 0x00000001,\n    WGPUBackendType_D3D11 = 0x00000002,\n    WGPUBackendType_D3D12 = 0x00000003,\n    WGPUBackendType_Metal = 0x00000004,\n    WGPUBackendType_Vulkan = 0x00000005,\n    WGPUBackendType_OpenGL = 0x00000006,\n    WGPUBackendType_OpenGLES = 0x00000007,\n    WGPUBackendType_Force32 = 0x7FFFFFFF\n} WGPUBackendType;\n\ntypedef enum WGPUBlendFactor {\n    WGPUBlendFactor_Zero = 0x00000000,\n    WGPUBlendFactor_One = 0x00000001,\n    WGPUBlendFactor_Src = 0x00000002,\n    WGPUBlendFactor_OneMinusSrc = 0x00000003,\n    WGPUBlendFactor_SrcAlpha = 0x00000004,\n    WGPUBlendFactor_OneMinusSrcAlpha = 0x00000005,\n    WGPUBlendFactor_Dst = 0x00000006,\n    WGPUBlendFactor_OneMinusDst = 0x00000007,\n    WGPUBlendFactor_DstAlpha = 0x00000008,\n    WGPUBlendFactor_OneMinusDstAlpha = 0x00000009,\n    WGPUBlendFactor_SrcAlphaSaturated = 0x0000000A,\n    WGPUBlendFactor_Constant = 0x0000000B,\n    WGPUBlendFactor_OneMinusConstant = 0x0000000C,\n    WGPUBlendFactor_Force32 = 0x7FFFFFFF\n} WGPUBlendFactor;\n\ntypedef enum WGPUBlendOperation {\n    WGPUBlendOperation_Add = 0x00000000,\n    WGPUBlendOperation_Subtract = 0x00000001,\n    WGPUBlendOperation_ReverseSubtract = 0x00000002,\n    WGPUBlendOperation_Min = 0x00000003,\n    WGPUBlendOperation_Max = 0x00000004,\n    WGPUBlendOperation_Force32 = 0x7FFFFFFF\n} WGPUBlendOperation;\n\ntypedef enum WGPUBufferBindingType {\n    WGPUBufferBindingType_Undefined = 0x00000000,\n    WGPUBufferBindingType_Uniform = 0x00000001,\n    WGPUBufferBindingType_Storage = 0x00000002,\n    WGPUBufferBindingType_ReadOnlyStorage = 0x00000003,\n    WGPUBufferBindingType_Force32 = 0x7FFFFFFF\n} WGPUBufferBindingType;\n\ntypedef enum WGPUBufferMapAsyncStatus {\n    WGPUBufferMapAsyncStatus_Success = 0x00000000,\n    WGPUBufferMapAsyncStatus_Error = 0x00000001,\n    WGPUBufferMapAsyncStatus_Unknown = 0x00000002,\n    WGPUBufferMapAsyncStatus_DeviceLost = 0x00000003,\n    WGPUBufferMapAsyncStatus_DestroyedBeforeCallback = 0x00000004,\n    WGPUBufferMapAsyncStatus_UnmappedBeforeCallback = 0x00000005,\n    WGPUBufferMapAsyncStatus_Force32 = 0x7FFFFFFF\n} WGPUBufferMapAsyncStatus;\n\ntypedef enum WGPUBufferMapState {\n    WGPUBufferMapState_Unmapped = 0x00000000,\n    WGPUBufferMapState_Pending = 0x00000001,\n    WGPUBufferMapState_Mapped = 0x00000002,\n    WGPUBufferMapState_Force32 = 0x7FFFFFFF\n} WGPUBufferMapState;\n\ntypedef enum WGPUCompareFunction {\n    WGPUCompareFunction_Undefined = 0x00000000,\n    WGPUCompareFunction_Never = 0x00000001,\n    WGPUCompareFunction_Less = 0x00000002,\n    WGPUCompareFunction_LessEqual = 0x00000003,\n    WGPUCompareFunction_Greater = 0x00000004,\n    WGPUCompareFunction_GreaterEqual = 0x00000005,\n    WGPUCompareFunction_Equal = 0x00000006,\n    WGPUCompareFunction_NotEqual = 0x00000007,\n    WGPUCompareFunction_Always = 0x00000008,\n    WGPUCompareFunction_Force32 = 0x7FFFFFFF\n} WGPUCompareFunction;\n\ntypedef enum WGPUCompilationInfoRequestStatus {\n    WGPUCompilationInfoRequestStatus_Success = 0x00000000,\n    WGPUCompilationInfoRequestStatus_Error = 0x00000001,\n    WGPUCompilationInfoRequestStatus_DeviceLost = 0x00000002,\n    WGPUCompilationInfoRequestStatus_Unknown = 0x00000003,\n    WGPUCompilationInfoRequestStatus_Force32 = 0x7FFFFFFF\n} WGPUCompilationInfoRequestStatus;\n\ntypedef enum WGPUCompilationMessageType {\n    WGPUCompilationMessageType_Error = 0x00000000,\n    WGPUCompilationMessageType_Warning = 0x00000001,\n    WGPUCompilationMessageType_Info = 0x00000002,\n    WGPUCompilationMessageType_Force32 = 0x7FFFFFFF\n} WGPUCompilationMessageType;\n\ntypedef enum WGPUComputePassTimestampLocation {\n    WGPUComputePassTimestampLocation_Beginning = 0x00000000,\n    WGPUComputePassTimestampLocation_End = 0x00000001,\n    WGPUComputePassTimestampLocation_Force32 = 0x7FFFFFFF\n} WGPUComputePassTimestampLocation;\n\ntypedef enum WGPUCreatePipelineAsyncStatus {\n    WGPUCreatePipelineAsyncStatus_Success = 0x00000000,\n    WGPUCreatePipelineAsyncStatus_Error = 0x00000001,\n    WGPUCreatePipelineAsyncStatus_DeviceLost = 0x00000002,\n    WGPUCreatePipelineAsyncStatus_DeviceDestroyed = 0x00000003,\n    WGPUCreatePipelineAsyncStatus_Unknown = 0x00000004,\n    WGPUCreatePipelineAsyncStatus_Force32 = 0x7FFFFFFF\n} WGPUCreatePipelineAsyncStatus;\n\ntypedef enum WGPUCullMode {\n    WGPUCullMode_None = 0x00000000,\n    WGPUCullMode_Front = 0x00000001,\n    WGPUCullMode_Back = 0x00000002,\n    WGPUCullMode_Force32 = 0x7FFFFFFF\n} WGPUCullMode;\n\ntypedef enum WGPUDeviceLostReason {\n    WGPUDeviceLostReason_Undefined = 0x00000000,\n    WGPUDeviceLostReason_Destroyed = 0x00000001,\n    WGPUDeviceLostReason_Force32 = 0x7FFFFFFF\n} WGPUDeviceLostReason;\n\ntypedef enum WGPUErrorFilter {\n    WGPUErrorFilter_Validation = 0x00000000,\n    WGPUErrorFilter_OutOfMemory = 0x00000001,\n    WGPUErrorFilter_Internal = 0x00000002,\n    WGPUErrorFilter_Force32 = 0x7FFFFFFF\n} WGPUErrorFilter;\n\ntypedef enum WGPUErrorType {\n    WGPUErrorType_NoError = 0x00000000,\n    WGPUErrorType_Validation = 0x00000001,\n    WGPUErrorType_OutOfMemory = 0x00000002,\n    WGPUErrorType_Internal = 0x00000003,\n    WGPUErrorType_Unknown = 0x00000004,\n    WGPUErrorType_DeviceLost = 0x00000005,\n    WGPUErrorType_Force32 = 0x7FFFFFFF\n} WGPUErrorType;\n\ntypedef enum WGPUExternalTextureRotation {\n    WGPUExternalTextureRotation_Rotate0Degrees = 0x00000000,\n    WGPUExternalTextureRotation_Rotate90Degrees = 0x00000001,\n    WGPUExternalTextureRotation_Rotate180Degrees = 0x00000002,\n    WGPUExternalTextureRotation_Rotate270Degrees = 0x00000003,\n    WGPUExternalTextureRotation_Force32 = 0x7FFFFFFF\n} WGPUExternalTextureRotation;\n\ntypedef enum WGPUFeatureName {\n    WGPUFeatureName_Undefined = 0x00000000,\n    WGPUFeatureName_DepthClipControl = 0x00000001,\n    WGPUFeatureName_Depth32FloatStencil8 = 0x00000002,\n    WGPUFeatureName_TimestampQuery = 0x00000003,\n    WGPUFeatureName_PipelineStatisticsQuery = 0x00000004,\n    WGPUFeatureName_TextureCompressionBC = 0x00000005,\n    WGPUFeatureName_TextureCompressionETC2 = 0x00000006,\n    WGPUFeatureName_TextureCompressionASTC = 0x00000007,\n    WGPUFeatureName_IndirectFirstInstance = 0x00000008,\n    WGPUFeatureName_ShaderF16 = 0x00000009,\n    WGPUFeatureName_RG11B10UfloatRenderable = 0x0000000A,\n    WGPUFeatureName_DawnShaderFloat16 = 0x000003E9,\n    WGPUFeatureName_DawnInternalUsages = 0x000003EA,\n    WGPUFeatureName_DawnMultiPlanarFormats = 0x000003EB,\n    WGPUFeatureName_DawnNative = 0x000003EC,\n    WGPUFeatureName_ChromiumExperimentalDp4a = 0x000003ED,\n    WGPUFeatureName_TimestampQueryInsidePasses = 0x000003EE,\n    WGPUFeatureName_Force32 = 0x7FFFFFFF\n} WGPUFeatureName;\n\ntypedef enum WGPUFilterMode {\n    WGPUFilterMode_Nearest = 0x00000000,\n    WGPUFilterMode_Linear = 0x00000001,\n    WGPUFilterMode_Force32 = 0x7FFFFFFF\n} WGPUFilterMode;\n\ntypedef enum WGPUFrontFace {\n    WGPUFrontFace_CCW = 0x00000000,\n    WGPUFrontFace_CW = 0x00000001,\n    WGPUFrontFace_Force32 = 0x7FFFFFFF\n} WGPUFrontFace;\n\ntypedef enum WGPUIndexFormat {\n    WGPUIndexFormat_Undefined = 0x00000000,\n    WGPUIndexFormat_Uint16 = 0x00000001,\n    WGPUIndexFormat_Uint32 = 0x00000002,\n    WGPUIndexFormat_Force32 = 0x7FFFFFFF\n} WGPUIndexFormat;\n\ntypedef enum WGPULoadOp {\n    WGPULoadOp_Undefined = 0x00000000,\n    WGPULoadOp_Clear = 0x00000001,\n    WGPULoadOp_Load = 0x00000002,\n    WGPULoadOp_Force32 = 0x7FFFFFFF\n} WGPULoadOp;\n\ntypedef enum WGPULoggingType {\n    WGPULoggingType_Verbose = 0x00000000,\n    WGPULoggingType_Info = 0x00000001,\n    WGPULoggingType_Warning = 0x00000002,\n    WGPULoggingType_Error = 0x00000003,\n    WGPULoggingType_Force32 = 0x7FFFFFFF\n} WGPULoggingType;\n\ntypedef enum WGPUPipelineStatisticName {\n    WGPUPipelineStatisticName_VertexShaderInvocations = 0x00000000,\n    WGPUPipelineStatisticName_ClipperInvocations = 0x00000001,\n    WGPUPipelineStatisticName_ClipperPrimitivesOut = 0x00000002,\n    WGPUPipelineStatisticName_FragmentShaderInvocations = 0x00000003,\n    WGPUPipelineStatisticName_ComputeShaderInvocations = 0x00000004,\n    WGPUPipelineStatisticName_Force32 = 0x7FFFFFFF\n} WGPUPipelineStatisticName;\n\ntypedef enum WGPUPowerPreference {\n    WGPUPowerPreference_Undefined = 0x00000000,\n    WGPUPowerPreference_LowPower = 0x00000001,\n    WGPUPowerPreference_HighPerformance = 0x00000002,\n    WGPUPowerPreference_Force32 = 0x7FFFFFFF\n} WGPUPowerPreference;\n\ntypedef enum WGPUPresentMode {\n    WGPUPresentMode_Immediate = 0x00000000,\n    WGPUPresentMode_Mailbox = 0x00000001,\n    WGPUPresentMode_Fifo = 0x00000002,\n    WGPUPresentMode_Force32 = 0x7FFFFFFF\n} WGPUPresentMode;\n\ntypedef enum WGPUPrimitiveTopology {\n    WGPUPrimitiveTopology_PointList = 0x00000000,\n    WGPUPrimitiveTopology_LineList = 0x00000001,\n    WGPUPrimitiveTopology_LineStrip = 0x00000002,\n    WGPUPrimitiveTopology_TriangleList = 0x00000003,\n    WGPUPrimitiveTopology_TriangleStrip = 0x00000004,\n    WGPUPrimitiveTopology_Force32 = 0x7FFFFFFF\n} WGPUPrimitiveTopology;\n\ntypedef enum WGPUQueryType {\n    WGPUQueryType_Occlusion = 0x00000000,\n    WGPUQueryType_PipelineStatistics = 0x00000001,\n    WGPUQueryType_Timestamp = 0x00000002,\n    WGPUQueryType_Force32 = 0x7FFFFFFF\n} WGPUQueryType;\n\ntypedef enum WGPUQueueWorkDoneStatus {\n    WGPUQueueWorkDoneStatus_Success = 0x00000000,\n    WGPUQueueWorkDoneStatus_Error = 0x00000001,\n    WGPUQueueWorkDoneStatus_Unknown = 0x00000002,\n    WGPUQueueWorkDoneStatus_DeviceLost = 0x00000003,\n    WGPUQueueWorkDoneStatus_Force32 = 0x7FFFFFFF\n} WGPUQueueWorkDoneStatus;\n\ntypedef enum WGPURenderPassTimestampLocation {\n    WGPURenderPassTimestampLocation_Beginning = 0x00000000,\n    WGPURenderPassTimestampLocation_End = 0x00000001,\n    WGPURenderPassTimestampLocation_Force32 = 0x7FFFFFFF\n} WGPURenderPassTimestampLocation;\n\ntypedef enum WGPURequestAdapterStatus {\n    WGPURequestAdapterStatus_Success = 0x00000000,\n    WGPURequestAdapterStatus_Unavailable = 0x00000001,\n    WGPURequestAdapterStatus_Error = 0x00000002,\n    WGPURequestAdapterStatus_Unknown = 0x00000003,\n    WGPURequestAdapterStatus_Force32 = 0x7FFFFFFF\n} WGPURequestAdapterStatus;\n\ntypedef enum WGPURequestDeviceStatus {\n    WGPURequestDeviceStatus_Success = 0x00000000,\n    WGPURequestDeviceStatus_Error = 0x00000001,\n    WGPURequestDeviceStatus_Unknown = 0x00000002,\n    WGPURequestDeviceStatus_Force32 = 0x7FFFFFFF\n} WGPURequestDeviceStatus;\n\ntypedef enum WGPUSType {\n    WGPUSType_Invalid = 0x00000000,\n    WGPUSType_SurfaceDescriptorFromMetalLayer = 0x00000001,\n    WGPUSType_SurfaceDescriptorFromWindowsHWND = 0x00000002,\n    WGPUSType_SurfaceDescriptorFromXlibWindow = 0x00000003,\n    WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004,\n    WGPUSType_ShaderModuleSPIRVDescriptor = 0x00000005,\n    WGPUSType_ShaderModuleWGSLDescriptor = 0x00000006,\n    WGPUSType_PrimitiveDepthClipControl = 0x00000007,\n    WGPUSType_SurfaceDescriptorFromWaylandSurface = 0x00000008,\n    WGPUSType_SurfaceDescriptorFromAndroidNativeWindow = 0x00000009,\n    WGPUSType_SurfaceDescriptorFromWindowsCoreWindow = 0x0000000B,\n    WGPUSType_ExternalTextureBindingEntry = 0x0000000C,\n    WGPUSType_ExternalTextureBindingLayout = 0x0000000D,\n    WGPUSType_SurfaceDescriptorFromWindowsSwapChainPanel = 0x0000000E,\n    WGPUSType_RenderPassDescriptorMaxDrawCount = 0x0000000F,\n    WGPUSType_DawnTextureInternalUsageDescriptor = 0x000003E8,\n    WGPUSType_DawnTogglesDeviceDescriptor = 0x000003EA,\n    WGPUSType_DawnEncoderInternalUsageDescriptor = 0x000003EB,\n    WGPUSType_DawnInstanceDescriptor = 0x000003EC,\n    WGPUSType_DawnCacheDeviceDescriptor = 0x000003ED,\n    WGPUSType_DawnAdapterPropertiesPowerPreference = 0x000003EE,\n    WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient = 0x000003EF,\n    WGPUSType_Force32 = 0x7FFFFFFF\n} WGPUSType;\n\ntypedef enum WGPUSamplerBindingType {\n    WGPUSamplerBindingType_Undefined = 0x00000000,\n    WGPUSamplerBindingType_Filtering = 0x00000001,\n    WGPUSamplerBindingType_NonFiltering = 0x00000002,\n    WGPUSamplerBindingType_Comparison = 0x00000003,\n    WGPUSamplerBindingType_Force32 = 0x7FFFFFFF\n} WGPUSamplerBindingType;\n\ntypedef enum WGPUStencilOperation {\n    WGPUStencilOperation_Keep = 0x00000000,\n    WGPUStencilOperation_Zero = 0x00000001,\n    WGPUStencilOperation_Replace = 0x00000002,\n    WGPUStencilOperation_Invert = 0x00000003,\n    WGPUStencilOperation_IncrementClamp = 0x00000004,\n    WGPUStencilOperation_DecrementClamp = 0x00000005,\n    WGPUStencilOperation_IncrementWrap = 0x00000006,\n    WGPUStencilOperation_DecrementWrap = 0x00000007,\n    WGPUStencilOperation_Force32 = 0x7FFFFFFF\n} WGPUStencilOperation;\n\ntypedef enum WGPUStorageTextureAccess {\n    WGPUStorageTextureAccess_Undefined = 0x00000000,\n    WGPUStorageTextureAccess_WriteOnly = 0x00000001,\n    WGPUStorageTextureAccess_Force32 = 0x7FFFFFFF\n} WGPUStorageTextureAccess;\n\ntypedef enum WGPUStoreOp {\n    WGPUStoreOp_Undefined = 0x00000000,\n    WGPUStoreOp_Store = 0x00000001,\n    WGPUStoreOp_Discard = 0x00000002,\n    WGPUStoreOp_Force32 = 0x7FFFFFFF\n} WGPUStoreOp;\n\ntypedef enum WGPUTextureAspect {\n    WGPUTextureAspect_All = 0x00000000,\n    WGPUTextureAspect_StencilOnly = 0x00000001,\n    WGPUTextureAspect_DepthOnly = 0x00000002,\n    WGPUTextureAspect_Plane0Only = 0x00000003,\n    WGPUTextureAspect_Plane1Only = 0x00000004,\n    WGPUTextureAspect_Force32 = 0x7FFFFFFF\n} WGPUTextureAspect;\n\ntypedef enum WGPUTextureComponentType {\n    WGPUTextureComponentType_Float = 0x00000000,\n    WGPUTextureComponentType_Sint = 0x00000001,\n    WGPUTextureComponentType_Uint = 0x00000002,\n    WGPUTextureComponentType_DepthComparison = 0x00000003,\n    WGPUTextureComponentType_Force32 = 0x7FFFFFFF\n} WGPUTextureComponentType;\n\ntypedef enum WGPUTextureDimension {\n    WGPUTextureDimension_1D = 0x00000000,\n    WGPUTextureDimension_2D = 0x00000001,\n    WGPUTextureDimension_3D = 0x00000002,\n    WGPUTextureDimension_Force32 = 0x7FFFFFFF\n} WGPUTextureDimension;\n\ntypedef enum WGPUTextureFormat {\n    WGPUTextureFormat_Undefined = 0x00000000,\n    WGPUTextureFormat_R8Unorm = 0x00000001,\n    WGPUTextureFormat_R8Snorm = 0x00000002,\n    WGPUTextureFormat_R8Uint = 0x00000003,\n    WGPUTextureFormat_R8Sint = 0x00000004,\n    WGPUTextureFormat_R16Uint = 0x00000005,\n    WGPUTextureFormat_R16Sint = 0x00000006,\n    WGPUTextureFormat_R16Float = 0x00000007,\n    WGPUTextureFormat_RG8Unorm = 0x00000008,\n    WGPUTextureFormat_RG8Snorm = 0x00000009,\n    WGPUTextureFormat_RG8Uint = 0x0000000A,\n    WGPUTextureFormat_RG8Sint = 0x0000000B,\n    WGPUTextureFormat_R32Float = 0x0000000C,\n    WGPUTextureFormat_R32Uint = 0x0000000D,\n    WGPUTextureFormat_R32Sint = 0x0000000E,\n    WGPUTextureFormat_RG16Uint = 0x0000000F,\n    WGPUTextureFormat_RG16Sint = 0x00000010,\n    WGPUTextureFormat_RG16Float = 0x00000011,\n    WGPUTextureFormat_RGBA8Unorm = 0x00000012,\n    WGPUTextureFormat_RGBA8UnormSrgb = 0x00000013,\n    WGPUTextureFormat_RGBA8Snorm = 0x00000014,\n    WGPUTextureFormat_RGBA8Uint = 0x00000015,\n    WGPUTextureFormat_RGBA8Sint = 0x00000016,\n    WGPUTextureFormat_BGRA8Unorm = 0x00000017,\n    WGPUTextureFormat_BGRA8UnormSrgb = 0x00000018,\n    WGPUTextureFormat_RGB10A2Unorm = 0x00000019,\n    WGPUTextureFormat_RG11B10Ufloat = 0x0000001A,\n    WGPUTextureFormat_RGB9E5Ufloat = 0x0000001B,\n    WGPUTextureFormat_RG32Float = 0x0000001C,\n    WGPUTextureFormat_RG32Uint = 0x0000001D,\n    WGPUTextureFormat_RG32Sint = 0x0000001E,\n    WGPUTextureFormat_RGBA16Uint = 0x0000001F,\n    WGPUTextureFormat_RGBA16Sint = 0x00000020,\n    WGPUTextureFormat_RGBA16Float = 0x00000021,\n    WGPUTextureFormat_RGBA32Float = 0x00000022,\n    WGPUTextureFormat_RGBA32Uint = 0x00000023,\n    WGPUTextureFormat_RGBA32Sint = 0x00000024,\n    WGPUTextureFormat_Stencil8 = 0x00000025,\n    WGPUTextureFormat_Depth16Unorm = 0x00000026,\n    WGPUTextureFormat_Depth24Plus = 0x00000027,\n    WGPUTextureFormat_Depth24PlusStencil8 = 0x00000028,\n    WGPUTextureFormat_Depth32Float = 0x00000029,\n    WGPUTextureFormat_Depth32FloatStencil8 = 0x0000002A,\n    WGPUTextureFormat_BC1RGBAUnorm = 0x0000002B,\n    WGPUTextureFormat_BC1RGBAUnormSrgb = 0x0000002C,\n    WGPUTextureFormat_BC2RGBAUnorm = 0x0000002D,\n    WGPUTextureFormat_BC2RGBAUnormSrgb = 0x0000002E,\n    WGPUTextureFormat_BC3RGBAUnorm = 0x0000002F,\n    WGPUTextureFormat_BC3RGBAUnormSrgb = 0x00000030,\n    WGPUTextureFormat_BC4RUnorm = 0x00000031,\n    WGPUTextureFormat_BC4RSnorm = 0x00000032,\n    WGPUTextureFormat_BC5RGUnorm = 0x00000033,\n    WGPUTextureFormat_BC5RGSnorm = 0x00000034,\n    WGPUTextureFormat_BC6HRGBUfloat = 0x00000035,\n    WGPUTextureFormat_BC6HRGBFloat = 0x00000036,\n    WGPUTextureFormat_BC7RGBAUnorm = 0x00000037,\n    WGPUTextureFormat_BC7RGBAUnormSrgb = 0x00000038,\n    WGPUTextureFormat_ETC2RGB8Unorm = 0x00000039,\n    WGPUTextureFormat_ETC2RGB8UnormSrgb = 0x0000003A,\n    WGPUTextureFormat_ETC2RGB8A1Unorm = 0x0000003B,\n    WGPUTextureFormat_ETC2RGB8A1UnormSrgb = 0x0000003C,\n    WGPUTextureFormat_ETC2RGBA8Unorm = 0x0000003D,\n    WGPUTextureFormat_ETC2RGBA8UnormSrgb = 0x0000003E,\n    WGPUTextureFormat_EACR11Unorm = 0x0000003F,\n    WGPUTextureFormat_EACR11Snorm = 0x00000040,\n    WGPUTextureFormat_EACRG11Unorm = 0x00000041,\n    WGPUTextureFormat_EACRG11Snorm = 0x00000042,\n    WGPUTextureFormat_ASTC4x4Unorm = 0x00000043,\n    WGPUTextureFormat_ASTC4x4UnormSrgb = 0x00000044,\n    WGPUTextureFormat_ASTC5x4Unorm = 0x00000045,\n    WGPUTextureFormat_ASTC5x4UnormSrgb = 0x00000046,\n    WGPUTextureFormat_ASTC5x5Unorm = 0x00000047,\n    WGPUTextureFormat_ASTC5x5UnormSrgb = 0x00000048,\n    WGPUTextureFormat_ASTC6x5Unorm = 0x00000049,\n    WGPUTextureFormat_ASTC6x5UnormSrgb = 0x0000004A,\n    WGPUTextureFormat_ASTC6x6Unorm = 0x0000004B,\n    WGPUTextureFormat_ASTC6x6UnormSrgb = 0x0000004C,\n    WGPUTextureFormat_ASTC8x5Unorm = 0x0000004D,\n    WGPUTextureFormat_ASTC8x5UnormSrgb = 0x0000004E,\n    WGPUTextureFormat_ASTC8x6Unorm = 0x0000004F,\n    WGPUTextureFormat_ASTC8x6UnormSrgb = 0x00000050,\n    WGPUTextureFormat_ASTC8x8Unorm = 0x00000051,\n    WGPUTextureFormat_ASTC8x8UnormSrgb = 0x00000052,\n    WGPUTextureFormat_ASTC10x5Unorm = 0x00000053,\n    WGPUTextureFormat_ASTC10x5UnormSrgb = 0x00000054,\n    WGPUTextureFormat_ASTC10x6Unorm = 0x00000055,\n    WGPUTextureFormat_ASTC10x6UnormSrgb = 0x00000056,\n    WGPUTextureFormat_ASTC10x8Unorm = 0x00000057,\n    WGPUTextureFormat_ASTC10x8UnormSrgb = 0x00000058,\n    WGPUTextureFormat_ASTC10x10Unorm = 0x00000059,\n    WGPUTextureFormat_ASTC10x10UnormSrgb = 0x0000005A,\n    WGPUTextureFormat_ASTC12x10Unorm = 0x0000005B,\n    WGPUTextureFormat_ASTC12x10UnormSrgb = 0x0000005C,\n    WGPUTextureFormat_ASTC12x12Unorm = 0x0000005D,\n    WGPUTextureFormat_ASTC12x12UnormSrgb = 0x0000005E,\n    WGPUTextureFormat_R8BG8Biplanar420Unorm = 0x0000005F,\n    WGPUTextureFormat_Force32 = 0x7FFFFFFF\n} WGPUTextureFormat;\n\ntypedef enum WGPUTextureSampleType {\n    WGPUTextureSampleType_Undefined = 0x00000000,\n    WGPUTextureSampleType_Float = 0x00000001,\n    WGPUTextureSampleType_UnfilterableFloat = 0x00000002,\n    WGPUTextureSampleType_Depth = 0x00000003,\n    WGPUTextureSampleType_Sint = 0x00000004,\n    WGPUTextureSampleType_Uint = 0x00000005,\n    WGPUTextureSampleType_Force32 = 0x7FFFFFFF\n} WGPUTextureSampleType;\n\ntypedef enum WGPUTextureViewDimension {\n    WGPUTextureViewDimension_Undefined = 0x00000000,\n    WGPUTextureViewDimension_1D = 0x00000001,\n    WGPUTextureViewDimension_2D = 0x00000002,\n    WGPUTextureViewDimension_2DArray = 0x00000003,\n    WGPUTextureViewDimension_Cube = 0x00000004,\n    WGPUTextureViewDimension_CubeArray = 0x00000005,\n    WGPUTextureViewDimension_3D = 0x00000006,\n    WGPUTextureViewDimension_Force32 = 0x7FFFFFFF\n} WGPUTextureViewDimension;\n\ntypedef enum WGPUVertexFormat {\n    WGPUVertexFormat_Undefined = 0x00000000,\n    WGPUVertexFormat_Uint8x2 = 0x00000001,\n    WGPUVertexFormat_Uint8x4 = 0x00000002,\n    WGPUVertexFormat_Sint8x2 = 0x00000003,\n    WGPUVertexFormat_Sint8x4 = 0x00000004,\n    WGPUVertexFormat_Unorm8x2 = 0x00000005,\n    WGPUVertexFormat_Unorm8x4 = 0x00000006,\n    WGPUVertexFormat_Snorm8x2 = 0x00000007,\n    WGPUVertexFormat_Snorm8x4 = 0x00000008,\n    WGPUVertexFormat_Uint16x2 = 0x00000009,\n    WGPUVertexFormat_Uint16x4 = 0x0000000A,\n    WGPUVertexFormat_Sint16x2 = 0x0000000B,\n    WGPUVertexFormat_Sint16x4 = 0x0000000C,\n    WGPUVertexFormat_Unorm16x2 = 0x0000000D,\n    WGPUVertexFormat_Unorm16x4 = 0x0000000E,\n    WGPUVertexFormat_Snorm16x2 = 0x0000000F,\n    WGPUVertexFormat_Snorm16x4 = 0x00000010,\n    WGPUVertexFormat_Float16x2 = 0x00000011,\n    WGPUVertexFormat_Float16x4 = 0x00000012,\n    WGPUVertexFormat_Float32 = 0x00000013,\n    WGPUVertexFormat_Float32x2 = 0x00000014,\n    WGPUVertexFormat_Float32x3 = 0x00000015,\n    WGPUVertexFormat_Float32x4 = 0x00000016,\n    WGPUVertexFormat_Uint32 = 0x00000017,\n    WGPUVertexFormat_Uint32x2 = 0x00000018,\n    WGPUVertexFormat_Uint32x3 = 0x00000019,\n    WGPUVertexFormat_Uint32x4 = 0x0000001A,\n    WGPUVertexFormat_Sint32 = 0x0000001B,\n    WGPUVertexFormat_Sint32x2 = 0x0000001C,\n    WGPUVertexFormat_Sint32x3 = 0x0000001D,\n    WGPUVertexFormat_Sint32x4 = 0x0000001E,\n    WGPUVertexFormat_Force32 = 0x7FFFFFFF\n} WGPUVertexFormat;\n\ntypedef enum WGPUVertexStepMode {\n    WGPUVertexStepMode_Vertex = 0x00000000,\n    WGPUVertexStepMode_Instance = 0x00000001,\n    WGPUVertexStepMode_VertexBufferNotUsed = 0x00000002,\n    WGPUVertexStepMode_Force32 = 0x7FFFFFFF\n} WGPUVertexStepMode;\n\ntypedef enum WGPUBufferUsage {\n    WGPUBufferUsage_None = 0x00000000,\n    WGPUBufferUsage_MapRead = 0x00000001,\n    WGPUBufferUsage_MapWrite = 0x00000002,\n    WGPUBufferUsage_CopySrc = 0x00000004,\n    WGPUBufferUsage_CopyDst = 0x00000008,\n    WGPUBufferUsage_Index = 0x00000010,\n    WGPUBufferUsage_Vertex = 0x00000020,\n    WGPUBufferUsage_Uniform = 0x00000040,\n    WGPUBufferUsage_Storage = 0x00000080,\n    WGPUBufferUsage_Indirect = 0x00000100,\n    WGPUBufferUsage_QueryResolve = 0x00000200,\n    WGPUBufferUsage_Force32 = 0x7FFFFFFF\n} WGPUBufferUsage;\ntypedef WGPUFlags WGPUBufferUsageFlags;\n\ntypedef enum WGPUColorWriteMask {\n    WGPUColorWriteMask_None = 0x00000000,\n    WGPUColorWriteMask_Red = 0x00000001,\n    WGPUColorWriteMask_Green = 0x00000002,\n    WGPUColorWriteMask_Blue = 0x00000004,\n    WGPUColorWriteMask_Alpha = 0x00000008,\n    WGPUColorWriteMask_All = 0x0000000F,\n    WGPUColorWriteMask_Force32 = 0x7FFFFFFF\n} WGPUColorWriteMask;\ntypedef WGPUFlags WGPUColorWriteMaskFlags;\n\ntypedef enum WGPUMapMode {\n    WGPUMapMode_None = 0x00000000,\n    WGPUMapMode_Read = 0x00000001,\n    WGPUMapMode_Write = 0x00000002,\n    WGPUMapMode_Force32 = 0x7FFFFFFF\n} WGPUMapMode;\ntypedef WGPUFlags WGPUMapModeFlags;\n\ntypedef enum WGPUShaderStage {\n    WGPUShaderStage_None = 0x00000000,\n    WGPUShaderStage_Vertex = 0x00000001,\n    WGPUShaderStage_Fragment = 0x00000002,\n    WGPUShaderStage_Compute = 0x00000004,\n    WGPUShaderStage_Force32 = 0x7FFFFFFF\n} WGPUShaderStage;\ntypedef WGPUFlags WGPUShaderStageFlags;\n\ntypedef enum WGPUTextureUsage {\n    WGPUTextureUsage_None = 0x00000000,\n    WGPUTextureUsage_CopySrc = 0x00000001,\n    WGPUTextureUsage_CopyDst = 0x00000002,\n    WGPUTextureUsage_TextureBinding = 0x00000004,\n    WGPUTextureUsage_StorageBinding = 0x00000008,\n    WGPUTextureUsage_RenderAttachment = 0x00000010,\n    WGPUTextureUsage_Present = 0x00000020,\n    WGPUTextureUsage_Force32 = 0x7FFFFFFF\n} WGPUTextureUsage;\ntypedef WGPUFlags WGPUTextureUsageFlags;\n\ntypedef struct WGPUChainedStruct {\n    struct WGPUChainedStruct const * next;\n    WGPUSType sType;\n} WGPUChainedStruct;\n\ntypedef struct WGPUChainedStructOut {\n    struct WGPUChainedStructOut * next;\n    WGPUSType sType;\n} WGPUChainedStructOut;\n\ntypedef struct WGPUAdapterProperties {\n    WGPUChainedStructOut * nextInChain;\n    uint32_t vendorID;\n    char const * vendorName;\n    char const * architecture;\n    uint32_t deviceID;\n    char const * name;\n    char const * driverDescription;\n    WGPUAdapterType adapterType;\n    WGPUBackendType backendType;\n} WGPUAdapterProperties;\n\ntypedef struct WGPUBindGroupEntry {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t binding;\n    WGPUBuffer buffer; // nullable\n    uint64_t offset;\n    uint64_t size;\n    WGPUSampler sampler; // nullable\n    WGPUTextureView textureView; // nullable\n} WGPUBindGroupEntry;\n\ntypedef struct WGPUBlendComponent {\n    WGPUBlendOperation operation;\n    WGPUBlendFactor srcFactor;\n    WGPUBlendFactor dstFactor;\n} WGPUBlendComponent;\n\ntypedef struct WGPUBufferBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUBufferBindingType type;\n    bool hasDynamicOffset;\n    uint64_t minBindingSize;\n} WGPUBufferBindingLayout;\n\ntypedef struct WGPUBufferDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUBufferUsageFlags usage;\n    uint64_t size;\n    bool mappedAtCreation;\n} WGPUBufferDescriptor;\n\ntypedef struct WGPUColor {\n    double r;\n    double g;\n    double b;\n    double a;\n} WGPUColor;\n\ntypedef struct WGPUCommandBufferDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n} WGPUCommandBufferDescriptor;\n\ntypedef struct WGPUCommandEncoderDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n} WGPUCommandEncoderDescriptor;\n\ntypedef struct WGPUCompilationMessage {\n    WGPUChainedStruct const * nextInChain;\n    char const * message; // nullable\n    WGPUCompilationMessageType type;\n    uint64_t lineNum;\n    uint64_t linePos;\n    uint64_t offset;\n    uint64_t length;\n    uint64_t utf16LinePos;\n    uint64_t utf16Offset;\n    uint64_t utf16Length;\n} WGPUCompilationMessage;\n\ntypedef struct WGPUComputePassTimestampWrite {\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n    WGPUComputePassTimestampLocation location;\n} WGPUComputePassTimestampWrite;\n\ntypedef struct WGPUConstantEntry {\n    WGPUChainedStruct const * nextInChain;\n    char const * key;\n    double value;\n} WGPUConstantEntry;\n\ntypedef struct WGPUCopyTextureForBrowserOptions {\n    WGPUChainedStruct const * nextInChain;\n    bool flipY;\n    bool needsColorSpaceConversion;\n    WGPUAlphaMode srcAlphaMode;\n    float const * srcTransferFunctionParameters; // nullable\n    float const * conversionMatrix; // nullable\n    float const * dstTransferFunctionParameters; // nullable\n    WGPUAlphaMode dstAlphaMode;\n    bool internalUsage;\n} WGPUCopyTextureForBrowserOptions;\n\n// Can be chained in WGPUAdapterProperties\ntypedef struct WGPUDawnAdapterPropertiesPowerPreference {\n    WGPUChainedStructOut chain;\n    WGPUPowerPreference powerPreference;\n} WGPUDawnAdapterPropertiesPowerPreference;\n\n// Can be chained in WGPUBufferDescriptor\ntypedef struct WGPUDawnBufferDescriptorErrorInfoFromWireClient {\n    WGPUChainedStruct chain;\n    bool outOfMemory;\n} WGPUDawnBufferDescriptorErrorInfoFromWireClient;\n\n// Can be chained in WGPUDeviceDescriptor\ntypedef struct WGPUDawnCacheDeviceDescriptor {\n    WGPUChainedStruct chain;\n    char const * isolationKey;\n} WGPUDawnCacheDeviceDescriptor;\n\n// Can be chained in WGPUCommandEncoderDescriptor\ntypedef struct WGPUDawnEncoderInternalUsageDescriptor {\n    WGPUChainedStruct chain;\n    bool useInternalUsages;\n} WGPUDawnEncoderInternalUsageDescriptor;\n\n// Can be chained in WGPUInstanceDescriptor\ntypedef struct WGPUDawnInstanceDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t additionalRuntimeSearchPathsCount;\n    const char* const * additionalRuntimeSearchPaths;\n} WGPUDawnInstanceDescriptor;\n\n// Can be chained in WGPUTextureDescriptor\ntypedef struct WGPUDawnTextureInternalUsageDescriptor {\n    WGPUChainedStruct chain;\n    WGPUTextureUsageFlags internalUsage;\n} WGPUDawnTextureInternalUsageDescriptor;\n\n// Can be chained in WGPUDeviceDescriptor\ntypedef struct WGPUDawnTogglesDeviceDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t forceEnabledTogglesCount;\n    const char* const * forceEnabledToggles;\n    uint32_t forceDisabledTogglesCount;\n    const char* const * forceDisabledToggles;\n} WGPUDawnTogglesDeviceDescriptor;\n\ntypedef struct WGPUExtent2D {\n    uint32_t width;\n    uint32_t height;\n} WGPUExtent2D;\n\ntypedef struct WGPUExtent3D {\n    uint32_t width;\n    uint32_t height;\n    uint32_t depthOrArrayLayers;\n} WGPUExtent3D;\n\n// Can be chained in WGPUBindGroupEntry\ntypedef struct WGPUExternalTextureBindingEntry {\n    WGPUChainedStruct chain;\n    WGPUExternalTexture externalTexture;\n} WGPUExternalTextureBindingEntry;\n\n// Can be chained in WGPUBindGroupLayoutEntry\ntypedef struct WGPUExternalTextureBindingLayout {\n    WGPUChainedStruct chain;\n} WGPUExternalTextureBindingLayout;\n\ntypedef struct WGPUInstanceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n} WGPUInstanceDescriptor;\n\ntypedef struct WGPULimits {\n    uint32_t maxTextureDimension1D;\n    uint32_t maxTextureDimension2D;\n    uint32_t maxTextureDimension3D;\n    uint32_t maxTextureArrayLayers;\n    uint32_t maxBindGroups;\n    uint32_t maxBindingsPerBindGroup;\n    uint32_t maxDynamicUniformBuffersPerPipelineLayout;\n    uint32_t maxDynamicStorageBuffersPerPipelineLayout;\n    uint32_t maxSampledTexturesPerShaderStage;\n    uint32_t maxSamplersPerShaderStage;\n    uint32_t maxStorageBuffersPerShaderStage;\n    uint32_t maxStorageTexturesPerShaderStage;\n    uint32_t maxUniformBuffersPerShaderStage;\n    uint64_t maxUniformBufferBindingSize;\n    uint64_t maxStorageBufferBindingSize;\n    uint32_t minUniformBufferOffsetAlignment;\n    uint32_t minStorageBufferOffsetAlignment;\n    uint32_t maxVertexBuffers;\n    uint64_t maxBufferSize;\n    uint32_t maxVertexAttributes;\n    uint32_t maxVertexBufferArrayStride;\n    uint32_t maxInterStageShaderComponents;\n    uint32_t maxInterStageShaderVariables;\n    uint32_t maxColorAttachments;\n    uint32_t maxColorAttachmentBytesPerSample;\n    uint32_t maxComputeWorkgroupStorageSize;\n    uint32_t maxComputeInvocationsPerWorkgroup;\n    uint32_t maxComputeWorkgroupSizeX;\n    uint32_t maxComputeWorkgroupSizeY;\n    uint32_t maxComputeWorkgroupSizeZ;\n    uint32_t maxComputeWorkgroupsPerDimension;\n} WGPULimits;\n\ntypedef struct WGPUMultisampleState {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t count;\n    uint32_t mask;\n    bool alphaToCoverageEnabled;\n} WGPUMultisampleState;\n\ntypedef struct WGPUOrigin2D {\n    uint32_t x;\n    uint32_t y;\n} WGPUOrigin2D;\n\ntypedef struct WGPUOrigin3D {\n    uint32_t x;\n    uint32_t y;\n    uint32_t z;\n} WGPUOrigin3D;\n\ntypedef struct WGPUPipelineLayoutDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    uint32_t bindGroupLayoutCount;\n    WGPUBindGroupLayout const * bindGroupLayouts;\n} WGPUPipelineLayoutDescriptor;\n\n// Can be chained in WGPUPrimitiveState\ntypedef struct WGPUPrimitiveDepthClipControl {\n    WGPUChainedStruct chain;\n    bool unclippedDepth;\n} WGPUPrimitiveDepthClipControl;\n\ntypedef struct WGPUPrimitiveState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUPrimitiveTopology topology;\n    WGPUIndexFormat stripIndexFormat;\n    WGPUFrontFace frontFace;\n    WGPUCullMode cullMode;\n} WGPUPrimitiveState;\n\ntypedef struct WGPUQuerySetDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUQueryType type;\n    uint32_t count;\n    WGPUPipelineStatisticName const * pipelineStatistics;\n    uint32_t pipelineStatisticsCount;\n} WGPUQuerySetDescriptor;\n\ntypedef struct WGPUQueueDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n} WGPUQueueDescriptor;\n\ntypedef struct WGPURenderBundleDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n} WGPURenderBundleDescriptor;\n\ntypedef struct WGPURenderBundleEncoderDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    uint32_t colorFormatsCount;\n    WGPUTextureFormat const * colorFormats;\n    WGPUTextureFormat depthStencilFormat;\n    uint32_t sampleCount;\n    bool depthReadOnly;\n    bool stencilReadOnly;\n} WGPURenderBundleEncoderDescriptor;\n\ntypedef struct WGPURenderPassDepthStencilAttachment {\n    WGPUTextureView view;\n    WGPULoadOp depthLoadOp;\n    WGPUStoreOp depthStoreOp;\n    float clearDepth;\n    float depthClearValue;\n    bool depthReadOnly;\n    WGPULoadOp stencilLoadOp;\n    WGPUStoreOp stencilStoreOp;\n    uint32_t clearStencil;\n    uint32_t stencilClearValue;\n    bool stencilReadOnly;\n} WGPURenderPassDepthStencilAttachment;\n\n// Can be chained in WGPURenderPassDescriptor\ntypedef struct WGPURenderPassDescriptorMaxDrawCount {\n    WGPUChainedStruct chain;\n    uint64_t maxDrawCount;\n} WGPURenderPassDescriptorMaxDrawCount;\n\ntypedef struct WGPURenderPassTimestampWrite {\n    WGPUQuerySet querySet;\n    uint32_t queryIndex;\n    WGPURenderPassTimestampLocation location;\n} WGPURenderPassTimestampWrite;\n\ntypedef struct WGPURequestAdapterOptions {\n    WGPUChainedStruct const * nextInChain;\n    WGPUSurface compatibleSurface; // nullable\n    WGPUPowerPreference powerPreference;\n    bool forceFallbackAdapter;\n} WGPURequestAdapterOptions;\n\ntypedef struct WGPUSamplerBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUSamplerBindingType type;\n} WGPUSamplerBindingLayout;\n\ntypedef struct WGPUSamplerDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUAddressMode addressModeU;\n    WGPUAddressMode addressModeV;\n    WGPUAddressMode addressModeW;\n    WGPUFilterMode magFilter;\n    WGPUFilterMode minFilter;\n    WGPUFilterMode mipmapFilter;\n    float lodMinClamp;\n    float lodMaxClamp;\n    WGPUCompareFunction compare;\n    uint16_t maxAnisotropy;\n} WGPUSamplerDescriptor;\n\ntypedef struct WGPUShaderModuleDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n} WGPUShaderModuleDescriptor;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUShaderModuleSPIRVDescriptor {\n    WGPUChainedStruct chain;\n    uint32_t codeSize;\n    uint32_t const * code;\n} WGPUShaderModuleSPIRVDescriptor;\n\n// Can be chained in WGPUShaderModuleDescriptor\ntypedef struct WGPUShaderModuleWGSLDescriptor {\n    WGPUChainedStruct chain;\n    char const * source;\n} WGPUShaderModuleWGSLDescriptor;\n\ntypedef struct WGPUStencilFaceState {\n    WGPUCompareFunction compare;\n    WGPUStencilOperation failOp;\n    WGPUStencilOperation depthFailOp;\n    WGPUStencilOperation passOp;\n} WGPUStencilFaceState;\n\ntypedef struct WGPUStorageTextureBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUStorageTextureAccess access;\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension viewDimension;\n} WGPUStorageTextureBindingLayout;\n\ntypedef struct WGPUSurfaceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n} WGPUSurfaceDescriptor;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromAndroidNativeWindow {\n    WGPUChainedStruct chain;\n    void * window;\n} WGPUSurfaceDescriptorFromAndroidNativeWindow;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromCanvasHTMLSelector {\n    WGPUChainedStruct chain;\n    char const * selector;\n} WGPUSurfaceDescriptorFromCanvasHTMLSelector;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromMetalLayer {\n    WGPUChainedStruct chain;\n    void * layer;\n} WGPUSurfaceDescriptorFromMetalLayer;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWaylandSurface {\n    WGPUChainedStruct chain;\n    void * display;\n    void * surface;\n} WGPUSurfaceDescriptorFromWaylandSurface;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWindowsCoreWindow {\n    WGPUChainedStruct chain;\n    void * coreWindow;\n} WGPUSurfaceDescriptorFromWindowsCoreWindow;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWindowsHWND {\n    WGPUChainedStruct chain;\n    void * hinstance;\n    void * hwnd;\n} WGPUSurfaceDescriptorFromWindowsHWND;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromWindowsSwapChainPanel {\n    WGPUChainedStruct chain;\n    void * swapChainPanel;\n} WGPUSurfaceDescriptorFromWindowsSwapChainPanel;\n\n// Can be chained in WGPUSurfaceDescriptor\ntypedef struct WGPUSurfaceDescriptorFromXlibWindow {\n    WGPUChainedStruct chain;\n    void * display;\n    uint32_t window;\n} WGPUSurfaceDescriptorFromXlibWindow;\n\ntypedef struct WGPUSwapChainDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUTextureUsageFlags usage;\n    WGPUTextureFormat format;\n    uint32_t width;\n    uint32_t height;\n    WGPUPresentMode presentMode;\n    uint64_t implementation;\n} WGPUSwapChainDescriptor;\n\ntypedef struct WGPUTextureBindingLayout {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureSampleType sampleType;\n    WGPUTextureViewDimension viewDimension;\n    bool multisampled;\n} WGPUTextureBindingLayout;\n\ntypedef struct WGPUTextureDataLayout {\n    WGPUChainedStruct const * nextInChain;\n    uint64_t offset;\n    uint32_t bytesPerRow;\n    uint32_t rowsPerImage;\n} WGPUTextureDataLayout;\n\ntypedef struct WGPUTextureViewDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUTextureFormat format;\n    WGPUTextureViewDimension dimension;\n    uint32_t baseMipLevel;\n    uint32_t mipLevelCount;\n    uint32_t baseArrayLayer;\n    uint32_t arrayLayerCount;\n    WGPUTextureAspect aspect;\n} WGPUTextureViewDescriptor;\n\ntypedef struct WGPUVertexAttribute {\n    WGPUVertexFormat format;\n    uint64_t offset;\n    uint32_t shaderLocation;\n} WGPUVertexAttribute;\n\ntypedef struct WGPUBindGroupDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUBindGroupLayout layout;\n    uint32_t entryCount;\n    WGPUBindGroupEntry const * entries;\n} WGPUBindGroupDescriptor;\n\ntypedef struct WGPUBindGroupLayoutEntry {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t binding;\n    WGPUShaderStageFlags visibility;\n    WGPUBufferBindingLayout buffer;\n    WGPUSamplerBindingLayout sampler;\n    WGPUTextureBindingLayout texture;\n    WGPUStorageTextureBindingLayout storageTexture;\n} WGPUBindGroupLayoutEntry;\n\ntypedef struct WGPUBlendState {\n    WGPUBlendComponent color;\n    WGPUBlendComponent alpha;\n} WGPUBlendState;\n\ntypedef struct WGPUCompilationInfo {\n    WGPUChainedStruct const * nextInChain;\n    uint32_t messageCount;\n    WGPUCompilationMessage const * messages;\n} WGPUCompilationInfo;\n\ntypedef struct WGPUComputePassDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    uint32_t timestampWriteCount;\n    WGPUComputePassTimestampWrite const * timestampWrites;\n} WGPUComputePassDescriptor;\n\ntypedef struct WGPUDepthStencilState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureFormat format;\n    bool depthWriteEnabled;\n    WGPUCompareFunction depthCompare;\n    WGPUStencilFaceState stencilFront;\n    WGPUStencilFaceState stencilBack;\n    uint32_t stencilReadMask;\n    uint32_t stencilWriteMask;\n    int32_t depthBias;\n    float depthBiasSlopeScale;\n    float depthBiasClamp;\n} WGPUDepthStencilState;\n\ntypedef struct WGPUExternalTextureDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUTextureView plane0;\n    WGPUTextureView plane1; // nullable\n    WGPUOrigin2D visibleOrigin;\n    WGPUExtent2D visibleSize;\n    bool doYuvToRgbConversionOnly;\n    float const * yuvToRgbConversionMatrix; // nullable\n    float const * srcTransferFunctionParameters;\n    float const * dstTransferFunctionParameters;\n    float const * gamutConversionMatrix;\n    bool flipY;\n    WGPUExternalTextureRotation rotation;\n} WGPUExternalTextureDescriptor;\n\ntypedef struct WGPUImageCopyBuffer {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureDataLayout layout;\n    WGPUBuffer buffer;\n} WGPUImageCopyBuffer;\n\ntypedef struct WGPUImageCopyExternalTexture {\n    WGPUChainedStruct const * nextInChain;\n    WGPUExternalTexture externalTexture;\n    WGPUOrigin3D origin;\n} WGPUImageCopyExternalTexture;\n\ntypedef struct WGPUImageCopyTexture {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTexture texture;\n    uint32_t mipLevel;\n    WGPUOrigin3D origin;\n    WGPUTextureAspect aspect;\n} WGPUImageCopyTexture;\n\ntypedef struct WGPUProgrammableStageDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    uint32_t constantCount;\n    WGPUConstantEntry const * constants;\n} WGPUProgrammableStageDescriptor;\n\ntypedef struct WGPURenderPassColorAttachment {\n    WGPUTextureView view; // nullable\n    WGPUTextureView resolveTarget; // nullable\n    WGPULoadOp loadOp;\n    WGPUStoreOp storeOp;\n    WGPUColor clearColor;\n    WGPUColor clearValue;\n} WGPURenderPassColorAttachment;\n\ntypedef struct WGPURequiredLimits {\n    WGPUChainedStruct const * nextInChain;\n    WGPULimits limits;\n} WGPURequiredLimits;\n\ntypedef struct WGPUSupportedLimits {\n    WGPUChainedStructOut * nextInChain;\n    WGPULimits limits;\n} WGPUSupportedLimits;\n\ntypedef struct WGPUTextureDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUTextureUsageFlags usage;\n    WGPUTextureDimension dimension;\n    WGPUExtent3D size;\n    WGPUTextureFormat format;\n    uint32_t mipLevelCount;\n    uint32_t sampleCount;\n    uint32_t viewFormatCount;\n    WGPUTextureFormat const * viewFormats;\n} WGPUTextureDescriptor;\n\ntypedef struct WGPUVertexBufferLayout {\n    uint64_t arrayStride;\n    WGPUVertexStepMode stepMode;\n    uint32_t attributeCount;\n    WGPUVertexAttribute const * attributes;\n} WGPUVertexBufferLayout;\n\ntypedef struct WGPUBindGroupLayoutDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    uint32_t entryCount;\n    WGPUBindGroupLayoutEntry const * entries;\n} WGPUBindGroupLayoutDescriptor;\n\ntypedef struct WGPUColorTargetState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUTextureFormat format;\n    WGPUBlendState const * blend; // nullable\n    WGPUColorWriteMaskFlags writeMask;\n} WGPUColorTargetState;\n\ntypedef struct WGPUComputePipelineDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUPipelineLayout layout; // nullable\n    WGPUProgrammableStageDescriptor compute;\n} WGPUComputePipelineDescriptor;\n\ntypedef struct WGPUDeviceDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    uint32_t requiredFeaturesCount;\n    WGPUFeatureName const * requiredFeatures;\n    WGPURequiredLimits const * requiredLimits; // nullable\n    WGPUQueueDescriptor defaultQueue;\n} WGPUDeviceDescriptor;\n\ntypedef struct WGPURenderPassDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    uint32_t colorAttachmentCount;\n    WGPURenderPassColorAttachment const * colorAttachments;\n    WGPURenderPassDepthStencilAttachment const * depthStencilAttachment; // nullable\n    WGPUQuerySet occlusionQuerySet; // nullable\n    uint32_t timestampWriteCount;\n    WGPURenderPassTimestampWrite const * timestampWrites;\n} WGPURenderPassDescriptor;\n\ntypedef struct WGPUVertexState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    uint32_t constantCount;\n    WGPUConstantEntry const * constants;\n    uint32_t bufferCount;\n    WGPUVertexBufferLayout const * buffers;\n} WGPUVertexState;\n\ntypedef struct WGPUFragmentState {\n    WGPUChainedStruct const * nextInChain;\n    WGPUShaderModule module;\n    char const * entryPoint;\n    uint32_t constantCount;\n    WGPUConstantEntry const * constants;\n    uint32_t targetCount;\n    WGPUColorTargetState const * targets;\n} WGPUFragmentState;\n\ntypedef struct WGPURenderPipelineDescriptor {\n    WGPUChainedStruct const * nextInChain;\n    char const * label; // nullable\n    WGPUPipelineLayout layout; // nullable\n    WGPUVertexState vertex;\n    WGPUPrimitiveState primitive;\n    WGPUDepthStencilState const * depthStencil; // nullable\n    WGPUMultisampleState multisample;\n    WGPUFragmentState const * fragment; // nullable\n} WGPURenderPipelineDescriptor;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*WGPUBufferMapCallback)(WGPUBufferMapAsyncStatus status, void * userdata);\ntypedef void (*WGPUCompilationInfoCallback)(WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void * userdata);\ntypedef void (*WGPUCreateComputePipelineAsyncCallback)(WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, char const * message, void * userdata);\ntypedef void (*WGPUCreateRenderPipelineAsyncCallback)(WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, char const * message, void * userdata);\ntypedef void (*WGPUDeviceLostCallback)(WGPUDeviceLostReason reason, char const * message, void * userdata);\ntypedef void (*WGPUErrorCallback)(WGPUErrorType type, char const * message, void * userdata);\ntypedef void (*WGPULoggingCallback)(WGPULoggingType type, char const * message, void * userdata);\ntypedef void (*WGPUProc)(void);\ntypedef void (*WGPUQueueWorkDoneCallback)(WGPUQueueWorkDoneStatus status, void * userdata);\ntypedef void (*WGPURequestAdapterCallback)(WGPURequestAdapterStatus status, WGPUAdapter adapter, char const * message, void * userdata);\ntypedef void (*WGPURequestDeviceCallback)(WGPURequestDeviceStatus status, WGPUDevice device, char const * message, void * userdata);\n\n#if !defined(WGPU_SKIP_PROCS)\n\ntypedef WGPUInstance (*WGPUProcCreateInstance)(WGPUInstanceDescriptor const * descriptor);\ntypedef WGPUProc (*WGPUProcGetProcAddress)(WGPUDevice device, char const * procName);\n\n// Procs of Adapter\ntypedef WGPUDevice (*WGPUProcAdapterCreateDevice)(WGPUAdapter adapter, WGPUDeviceDescriptor const * descriptor /* nullable */);\ntypedef size_t (*WGPUProcAdapterEnumerateFeatures)(WGPUAdapter adapter, WGPUFeatureName * features);\ntypedef bool (*WGPUProcAdapterGetLimits)(WGPUAdapter adapter, WGPUSupportedLimits * limits);\ntypedef void (*WGPUProcAdapterGetProperties)(WGPUAdapter adapter, WGPUAdapterProperties * properties);\ntypedef bool (*WGPUProcAdapterHasFeature)(WGPUAdapter adapter, WGPUFeatureName feature);\ntypedef void (*WGPUProcAdapterRequestDevice)(WGPUAdapter adapter, WGPUDeviceDescriptor const * descriptor /* nullable */, WGPURequestDeviceCallback callback, void * userdata);\ntypedef void (*WGPUProcAdapterReference)(WGPUAdapter adapter);\ntypedef void (*WGPUProcAdapterRelease)(WGPUAdapter adapter);\n\n// Procs of BindGroup\ntypedef void (*WGPUProcBindGroupSetLabel)(WGPUBindGroup bindGroup, char const * label);\ntypedef void (*WGPUProcBindGroupReference)(WGPUBindGroup bindGroup);\ntypedef void (*WGPUProcBindGroupRelease)(WGPUBindGroup bindGroup);\n\n// Procs of BindGroupLayout\ntypedef void (*WGPUProcBindGroupLayoutSetLabel)(WGPUBindGroupLayout bindGroupLayout, char const * label);\ntypedef void (*WGPUProcBindGroupLayoutReference)(WGPUBindGroupLayout bindGroupLayout);\ntypedef void (*WGPUProcBindGroupLayoutRelease)(WGPUBindGroupLayout bindGroupLayout);\n\n// Procs of Buffer\ntypedef void (*WGPUProcBufferDestroy)(WGPUBuffer buffer);\ntypedef void const * (*WGPUProcBufferGetConstMappedRange)(WGPUBuffer buffer, size_t offset, size_t size);\ntypedef WGPUBufferMapState (*WGPUProcBufferGetMapState)(WGPUBuffer buffer);\ntypedef void * (*WGPUProcBufferGetMappedRange)(WGPUBuffer buffer, size_t offset, size_t size);\ntypedef uint64_t (*WGPUProcBufferGetSize)(WGPUBuffer buffer);\ntypedef WGPUBufferUsage (*WGPUProcBufferGetUsage)(WGPUBuffer buffer);\ntypedef void (*WGPUProcBufferMapAsync)(WGPUBuffer buffer, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata);\ntypedef void (*WGPUProcBufferSetLabel)(WGPUBuffer buffer, char const * label);\ntypedef void (*WGPUProcBufferUnmap)(WGPUBuffer buffer);\ntypedef void (*WGPUProcBufferReference)(WGPUBuffer buffer);\ntypedef void (*WGPUProcBufferRelease)(WGPUBuffer buffer);\n\n// Procs of CommandBuffer\ntypedef void (*WGPUProcCommandBufferSetLabel)(WGPUCommandBuffer commandBuffer, char const * label);\ntypedef void (*WGPUProcCommandBufferReference)(WGPUCommandBuffer commandBuffer);\ntypedef void (*WGPUProcCommandBufferRelease)(WGPUCommandBuffer commandBuffer);\n\n// Procs of CommandEncoder\ntypedef WGPUComputePassEncoder (*WGPUProcCommandEncoderBeginComputePass)(WGPUCommandEncoder commandEncoder, WGPUComputePassDescriptor const * descriptor /* nullable */);\ntypedef WGPURenderPassEncoder (*WGPUProcCommandEncoderBeginRenderPass)(WGPUCommandEncoder commandEncoder, WGPURenderPassDescriptor const * descriptor);\ntypedef void (*WGPUProcCommandEncoderClearBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t offset, uint64_t size);\ntypedef void (*WGPUProcCommandEncoderCopyBufferToBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size);\ntypedef void (*WGPUProcCommandEncoderCopyBufferToTexture)(WGPUCommandEncoder commandEncoder, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\ntypedef void (*WGPUProcCommandEncoderCopyTextureToBuffer)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize);\ntypedef void (*WGPUProcCommandEncoderCopyTextureToTexture)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\ntypedef void (*WGPUProcCommandEncoderCopyTextureToTextureInternal)(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\ntypedef WGPUCommandBuffer (*WGPUProcCommandEncoderFinish)(WGPUCommandEncoder commandEncoder, WGPUCommandBufferDescriptor const * descriptor /* nullable */);\ntypedef void (*WGPUProcCommandEncoderInjectValidationError)(WGPUCommandEncoder commandEncoder, char const * message);\ntypedef void (*WGPUProcCommandEncoderInsertDebugMarker)(WGPUCommandEncoder commandEncoder, char const * markerLabel);\ntypedef void (*WGPUProcCommandEncoderPopDebugGroup)(WGPUCommandEncoder commandEncoder);\ntypedef void (*WGPUProcCommandEncoderPushDebugGroup)(WGPUCommandEncoder commandEncoder, char const * groupLabel);\ntypedef void (*WGPUProcCommandEncoderResolveQuerySet)(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset);\ntypedef void (*WGPUProcCommandEncoderSetLabel)(WGPUCommandEncoder commandEncoder, char const * label);\ntypedef void (*WGPUProcCommandEncoderWriteBuffer)(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size);\ntypedef void (*WGPUProcCommandEncoderWriteTimestamp)(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t queryIndex);\ntypedef void (*WGPUProcCommandEncoderReference)(WGPUCommandEncoder commandEncoder);\ntypedef void (*WGPUProcCommandEncoderRelease)(WGPUCommandEncoder commandEncoder);\n\n// Procs of ComputePassEncoder\ntypedef void (*WGPUProcComputePassEncoderDispatch)(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\ntypedef void (*WGPUProcComputePassEncoderDispatchIndirect)(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\ntypedef void (*WGPUProcComputePassEncoderDispatchWorkgroups)(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\ntypedef void (*WGPUProcComputePassEncoderDispatchWorkgroupsIndirect)(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\ntypedef void (*WGPUProcComputePassEncoderEnd)(WGPUComputePassEncoder computePassEncoder);\ntypedef void (*WGPUProcComputePassEncoderEndPass)(WGPUComputePassEncoder computePassEncoder);\ntypedef void (*WGPUProcComputePassEncoderInsertDebugMarker)(WGPUComputePassEncoder computePassEncoder, char const * markerLabel);\ntypedef void (*WGPUProcComputePassEncoderPopDebugGroup)(WGPUComputePassEncoder computePassEncoder);\ntypedef void (*WGPUProcComputePassEncoderPushDebugGroup)(WGPUComputePassEncoder computePassEncoder, char const * groupLabel);\ntypedef void (*WGPUProcComputePassEncoderSetBindGroup)(WGPUComputePassEncoder computePassEncoder, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\ntypedef void (*WGPUProcComputePassEncoderSetLabel)(WGPUComputePassEncoder computePassEncoder, char const * label);\ntypedef void (*WGPUProcComputePassEncoderSetPipeline)(WGPUComputePassEncoder computePassEncoder, WGPUComputePipeline pipeline);\ntypedef void (*WGPUProcComputePassEncoderWriteTimestamp)(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex);\ntypedef void (*WGPUProcComputePassEncoderReference)(WGPUComputePassEncoder computePassEncoder);\ntypedef void (*WGPUProcComputePassEncoderRelease)(WGPUComputePassEncoder computePassEncoder);\n\n// Procs of ComputePipeline\ntypedef WGPUBindGroupLayout (*WGPUProcComputePipelineGetBindGroupLayout)(WGPUComputePipeline computePipeline, uint32_t groupIndex);\ntypedef void (*WGPUProcComputePipelineSetLabel)(WGPUComputePipeline computePipeline, char const * label);\ntypedef void (*WGPUProcComputePipelineReference)(WGPUComputePipeline computePipeline);\ntypedef void (*WGPUProcComputePipelineRelease)(WGPUComputePipeline computePipeline);\n\n// Procs of Device\ntypedef WGPUBindGroup (*WGPUProcDeviceCreateBindGroup)(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor);\ntypedef WGPUBindGroupLayout (*WGPUProcDeviceCreateBindGroupLayout)(WGPUDevice device, WGPUBindGroupLayoutDescriptor const * descriptor);\ntypedef WGPUBuffer (*WGPUProcDeviceCreateBuffer)(WGPUDevice device, WGPUBufferDescriptor const * descriptor);\ntypedef WGPUCommandEncoder (*WGPUProcDeviceCreateCommandEncoder)(WGPUDevice device, WGPUCommandEncoderDescriptor const * descriptor /* nullable */);\ntypedef WGPUComputePipeline (*WGPUProcDeviceCreateComputePipeline)(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor);\ntypedef void (*WGPUProcDeviceCreateComputePipelineAsync)(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata);\ntypedef WGPUBuffer (*WGPUProcDeviceCreateErrorBuffer)(WGPUDevice device, WGPUBufferDescriptor const * descriptor);\ntypedef WGPUExternalTexture (*WGPUProcDeviceCreateErrorExternalTexture)(WGPUDevice device);\ntypedef WGPUTexture (*WGPUProcDeviceCreateErrorTexture)(WGPUDevice device, WGPUTextureDescriptor const * descriptor);\ntypedef WGPUExternalTexture (*WGPUProcDeviceCreateExternalTexture)(WGPUDevice device, WGPUExternalTextureDescriptor const * externalTextureDescriptor);\ntypedef WGPUPipelineLayout (*WGPUProcDeviceCreatePipelineLayout)(WGPUDevice device, WGPUPipelineLayoutDescriptor const * descriptor);\ntypedef WGPUQuerySet (*WGPUProcDeviceCreateQuerySet)(WGPUDevice device, WGPUQuerySetDescriptor const * descriptor);\ntypedef WGPURenderBundleEncoder (*WGPUProcDeviceCreateRenderBundleEncoder)(WGPUDevice device, WGPURenderBundleEncoderDescriptor const * descriptor);\ntypedef WGPURenderPipeline (*WGPUProcDeviceCreateRenderPipeline)(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor);\ntypedef void (*WGPUProcDeviceCreateRenderPipelineAsync)(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata);\ntypedef WGPUSampler (*WGPUProcDeviceCreateSampler)(WGPUDevice device, WGPUSamplerDescriptor const * descriptor /* nullable */);\ntypedef WGPUShaderModule (*WGPUProcDeviceCreateShaderModule)(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor);\ntypedef WGPUSwapChain (*WGPUProcDeviceCreateSwapChain)(WGPUDevice device, WGPUSurface surface /* nullable */, WGPUSwapChainDescriptor const * descriptor);\ntypedef WGPUTexture (*WGPUProcDeviceCreateTexture)(WGPUDevice device, WGPUTextureDescriptor const * descriptor);\ntypedef void (*WGPUProcDeviceDestroy)(WGPUDevice device);\ntypedef size_t (*WGPUProcDeviceEnumerateFeatures)(WGPUDevice device, WGPUFeatureName * features);\ntypedef void (*WGPUProcDeviceForceLoss)(WGPUDevice device, WGPUDeviceLostReason type, char const * message);\ntypedef WGPUAdapter (*WGPUProcDeviceGetAdapter)(WGPUDevice device);\ntypedef bool (*WGPUProcDeviceGetLimits)(WGPUDevice device, WGPUSupportedLimits * limits);\ntypedef WGPUQueue (*WGPUProcDeviceGetQueue)(WGPUDevice device);\ntypedef bool (*WGPUProcDeviceHasFeature)(WGPUDevice device, WGPUFeatureName feature);\ntypedef void (*WGPUProcDeviceInjectError)(WGPUDevice device, WGPUErrorType type, char const * message);\ntypedef bool (*WGPUProcDevicePopErrorScope)(WGPUDevice device, WGPUErrorCallback callback, void * userdata);\ntypedef void (*WGPUProcDevicePushErrorScope)(WGPUDevice device, WGPUErrorFilter filter);\ntypedef void (*WGPUProcDeviceSetDeviceLostCallback)(WGPUDevice device, WGPUDeviceLostCallback callback, void * userdata);\ntypedef void (*WGPUProcDeviceSetLabel)(WGPUDevice device, char const * label);\ntypedef void (*WGPUProcDeviceSetLoggingCallback)(WGPUDevice device, WGPULoggingCallback callback, void * userdata);\ntypedef void (*WGPUProcDeviceSetUncapturedErrorCallback)(WGPUDevice device, WGPUErrorCallback callback, void * userdata);\ntypedef void (*WGPUProcDeviceTick)(WGPUDevice device);\ntypedef void (*WGPUProcDeviceValidateTextureDescriptor)(WGPUDevice device, WGPUTextureDescriptor const * descriptor);\ntypedef void (*WGPUProcDeviceReference)(WGPUDevice device);\ntypedef void (*WGPUProcDeviceRelease)(WGPUDevice device);\n\n// Procs of ExternalTexture\ntypedef void (*WGPUProcExternalTextureDestroy)(WGPUExternalTexture externalTexture);\ntypedef void (*WGPUProcExternalTextureSetLabel)(WGPUExternalTexture externalTexture, char const * label);\ntypedef void (*WGPUProcExternalTextureReference)(WGPUExternalTexture externalTexture);\ntypedef void (*WGPUProcExternalTextureRelease)(WGPUExternalTexture externalTexture);\n\n// Procs of Instance\ntypedef WGPUSurface (*WGPUProcInstanceCreateSurface)(WGPUInstance instance, WGPUSurfaceDescriptor const * descriptor);\ntypedef void (*WGPUProcInstanceRequestAdapter)(WGPUInstance instance, WGPURequestAdapterOptions const * options /* nullable */, WGPURequestAdapterCallback callback, void * userdata);\ntypedef void (*WGPUProcInstanceReference)(WGPUInstance instance);\ntypedef void (*WGPUProcInstanceRelease)(WGPUInstance instance);\n\n// Procs of PipelineLayout\ntypedef void (*WGPUProcPipelineLayoutSetLabel)(WGPUPipelineLayout pipelineLayout, char const * label);\ntypedef void (*WGPUProcPipelineLayoutReference)(WGPUPipelineLayout pipelineLayout);\ntypedef void (*WGPUProcPipelineLayoutRelease)(WGPUPipelineLayout pipelineLayout);\n\n// Procs of QuerySet\ntypedef void (*WGPUProcQuerySetDestroy)(WGPUQuerySet querySet);\ntypedef uint32_t (*WGPUProcQuerySetGetCount)(WGPUQuerySet querySet);\ntypedef WGPUQueryType (*WGPUProcQuerySetGetType)(WGPUQuerySet querySet);\ntypedef void (*WGPUProcQuerySetSetLabel)(WGPUQuerySet querySet, char const * label);\ntypedef void (*WGPUProcQuerySetReference)(WGPUQuerySet querySet);\ntypedef void (*WGPUProcQuerySetRelease)(WGPUQuerySet querySet);\n\n// Procs of Queue\ntypedef void (*WGPUProcQueueCopyExternalTextureForBrowser)(WGPUQueue queue, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\ntypedef void (*WGPUProcQueueCopyTextureForBrowser)(WGPUQueue queue, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\ntypedef void (*WGPUProcQueueOnSubmittedWorkDone)(WGPUQueue queue, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata);\ntypedef void (*WGPUProcQueueSetLabel)(WGPUQueue queue, char const * label);\ntypedef void (*WGPUProcQueueSubmit)(WGPUQueue queue, uint32_t commandCount, WGPUCommandBuffer const * commands);\ntypedef void (*WGPUProcQueueWriteBuffer)(WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size);\ntypedef void (*WGPUProcQueueWriteTexture)(WGPUQueue queue, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize);\ntypedef void (*WGPUProcQueueReference)(WGPUQueue queue);\ntypedef void (*WGPUProcQueueRelease)(WGPUQueue queue);\n\n// Procs of RenderBundle\ntypedef void (*WGPUProcRenderBundleReference)(WGPURenderBundle renderBundle);\ntypedef void (*WGPUProcRenderBundleRelease)(WGPURenderBundle renderBundle);\n\n// Procs of RenderBundleEncoder\ntypedef void (*WGPUProcRenderBundleEncoderDraw)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndexed)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndexedIndirect)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\ntypedef void (*WGPUProcRenderBundleEncoderDrawIndirect)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\ntypedef WGPURenderBundle (*WGPUProcRenderBundleEncoderFinish)(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderBundleDescriptor const * descriptor /* nullable */);\ntypedef void (*WGPUProcRenderBundleEncoderInsertDebugMarker)(WGPURenderBundleEncoder renderBundleEncoder, char const * markerLabel);\ntypedef void (*WGPUProcRenderBundleEncoderPopDebugGroup)(WGPURenderBundleEncoder renderBundleEncoder);\ntypedef void (*WGPUProcRenderBundleEncoderPushDebugGroup)(WGPURenderBundleEncoder renderBundleEncoder, char const * groupLabel);\ntypedef void (*WGPUProcRenderBundleEncoderSetBindGroup)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\ntypedef void (*WGPUProcRenderBundleEncoderSetIndexBuffer)(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\ntypedef void (*WGPUProcRenderBundleEncoderSetLabel)(WGPURenderBundleEncoder renderBundleEncoder, char const * label);\ntypedef void (*WGPUProcRenderBundleEncoderSetPipeline)(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderPipeline pipeline);\ntypedef void (*WGPUProcRenderBundleEncoderSetVertexBuffer)(WGPURenderBundleEncoder renderBundleEncoder, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\ntypedef void (*WGPUProcRenderBundleEncoderReference)(WGPURenderBundleEncoder renderBundleEncoder);\ntypedef void (*WGPUProcRenderBundleEncoderRelease)(WGPURenderBundleEncoder renderBundleEncoder);\n\n// Procs of RenderPassEncoder\ntypedef void (*WGPUProcRenderPassEncoderBeginOcclusionQuery)(WGPURenderPassEncoder renderPassEncoder, uint32_t queryIndex);\ntypedef void (*WGPUProcRenderPassEncoderDraw)(WGPURenderPassEncoder renderPassEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\ntypedef void (*WGPUProcRenderPassEncoderDrawIndexed)(WGPURenderPassEncoder renderPassEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\ntypedef void (*WGPUProcRenderPassEncoderDrawIndexedIndirect)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\ntypedef void (*WGPUProcRenderPassEncoderDrawIndirect)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\ntypedef void (*WGPUProcRenderPassEncoderEnd)(WGPURenderPassEncoder renderPassEncoder);\ntypedef void (*WGPUProcRenderPassEncoderEndOcclusionQuery)(WGPURenderPassEncoder renderPassEncoder);\ntypedef void (*WGPUProcRenderPassEncoderEndPass)(WGPURenderPassEncoder renderPassEncoder);\ntypedef void (*WGPUProcRenderPassEncoderExecuteBundles)(WGPURenderPassEncoder renderPassEncoder, uint32_t bundleCount, WGPURenderBundle const * bundles);\ntypedef void (*WGPUProcRenderPassEncoderInsertDebugMarker)(WGPURenderPassEncoder renderPassEncoder, char const * markerLabel);\ntypedef void (*WGPUProcRenderPassEncoderPopDebugGroup)(WGPURenderPassEncoder renderPassEncoder);\ntypedef void (*WGPUProcRenderPassEncoderPushDebugGroup)(WGPURenderPassEncoder renderPassEncoder, char const * groupLabel);\ntypedef void (*WGPUProcRenderPassEncoderSetBindGroup)(WGPURenderPassEncoder renderPassEncoder, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\ntypedef void (*WGPUProcRenderPassEncoderSetBlendConstant)(WGPURenderPassEncoder renderPassEncoder, WGPUColor const * color);\ntypedef void (*WGPUProcRenderPassEncoderSetIndexBuffer)(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\ntypedef void (*WGPUProcRenderPassEncoderSetLabel)(WGPURenderPassEncoder renderPassEncoder, char const * label);\ntypedef void (*WGPUProcRenderPassEncoderSetPipeline)(WGPURenderPassEncoder renderPassEncoder, WGPURenderPipeline pipeline);\ntypedef void (*WGPUProcRenderPassEncoderSetScissorRect)(WGPURenderPassEncoder renderPassEncoder, uint32_t x, uint32_t y, uint32_t width, uint32_t height);\ntypedef void (*WGPUProcRenderPassEncoderSetStencilReference)(WGPURenderPassEncoder renderPassEncoder, uint32_t reference);\ntypedef void (*WGPUProcRenderPassEncoderSetVertexBuffer)(WGPURenderPassEncoder renderPassEncoder, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\ntypedef void (*WGPUProcRenderPassEncoderSetViewport)(WGPURenderPassEncoder renderPassEncoder, float x, float y, float width, float height, float minDepth, float maxDepth);\ntypedef void (*WGPUProcRenderPassEncoderWriteTimestamp)(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex);\ntypedef void (*WGPUProcRenderPassEncoderReference)(WGPURenderPassEncoder renderPassEncoder);\ntypedef void (*WGPUProcRenderPassEncoderRelease)(WGPURenderPassEncoder renderPassEncoder);\n\n// Procs of RenderPipeline\ntypedef WGPUBindGroupLayout (*WGPUProcRenderPipelineGetBindGroupLayout)(WGPURenderPipeline renderPipeline, uint32_t groupIndex);\ntypedef void (*WGPUProcRenderPipelineSetLabel)(WGPURenderPipeline renderPipeline, char const * label);\ntypedef void (*WGPUProcRenderPipelineReference)(WGPURenderPipeline renderPipeline);\ntypedef void (*WGPUProcRenderPipelineRelease)(WGPURenderPipeline renderPipeline);\n\n// Procs of Sampler\ntypedef void (*WGPUProcSamplerSetLabel)(WGPUSampler sampler, char const * label);\ntypedef void (*WGPUProcSamplerReference)(WGPUSampler sampler);\ntypedef void (*WGPUProcSamplerRelease)(WGPUSampler sampler);\n\n// Procs of ShaderModule\ntypedef void (*WGPUProcShaderModuleGetCompilationInfo)(WGPUShaderModule shaderModule, WGPUCompilationInfoCallback callback, void * userdata);\ntypedef void (*WGPUProcShaderModuleSetLabel)(WGPUShaderModule shaderModule, char const * label);\ntypedef void (*WGPUProcShaderModuleReference)(WGPUShaderModule shaderModule);\ntypedef void (*WGPUProcShaderModuleRelease)(WGPUShaderModule shaderModule);\n\n// Procs of Surface\ntypedef void (*WGPUProcSurfaceReference)(WGPUSurface surface);\ntypedef void (*WGPUProcSurfaceRelease)(WGPUSurface surface);\n\n// Procs of SwapChain\ntypedef void (*WGPUProcSwapChainConfigure)(WGPUSwapChain swapChain, WGPUTextureFormat format, WGPUTextureUsageFlags allowedUsage, uint32_t width, uint32_t height);\ntypedef WGPUTextureView (*WGPUProcSwapChainGetCurrentTextureView)(WGPUSwapChain swapChain);\ntypedef void (*WGPUProcSwapChainPresent)(WGPUSwapChain swapChain);\ntypedef void (*WGPUProcSwapChainReference)(WGPUSwapChain swapChain);\ntypedef void (*WGPUProcSwapChainRelease)(WGPUSwapChain swapChain);\n\n// Procs of Texture\ntypedef WGPUTextureView (*WGPUProcTextureCreateView)(WGPUTexture texture, WGPUTextureViewDescriptor const * descriptor /* nullable */);\ntypedef void (*WGPUProcTextureDestroy)(WGPUTexture texture);\ntypedef uint32_t (*WGPUProcTextureGetDepthOrArrayLayers)(WGPUTexture texture);\ntypedef WGPUTextureDimension (*WGPUProcTextureGetDimension)(WGPUTexture texture);\ntypedef WGPUTextureFormat (*WGPUProcTextureGetFormat)(WGPUTexture texture);\ntypedef uint32_t (*WGPUProcTextureGetHeight)(WGPUTexture texture);\ntypedef uint32_t (*WGPUProcTextureGetMipLevelCount)(WGPUTexture texture);\ntypedef uint32_t (*WGPUProcTextureGetSampleCount)(WGPUTexture texture);\ntypedef WGPUTextureUsage (*WGPUProcTextureGetUsage)(WGPUTexture texture);\ntypedef uint32_t (*WGPUProcTextureGetWidth)(WGPUTexture texture);\ntypedef void (*WGPUProcTextureSetLabel)(WGPUTexture texture, char const * label);\ntypedef void (*WGPUProcTextureReference)(WGPUTexture texture);\ntypedef void (*WGPUProcTextureRelease)(WGPUTexture texture);\n\n// Procs of TextureView\ntypedef void (*WGPUProcTextureViewSetLabel)(WGPUTextureView textureView, char const * label);\ntypedef void (*WGPUProcTextureViewReference)(WGPUTextureView textureView);\ntypedef void (*WGPUProcTextureViewRelease)(WGPUTextureView textureView);\n\n#endif  // !defined(WGPU_SKIP_PROCS)\n\n#if !defined(WGPU_SKIP_DECLARATIONS)\n\nWGPU_EXPORT WGPUInstance wgpuCreateInstance(WGPUInstanceDescriptor const * descriptor);\nWGPU_EXPORT WGPUProc wgpuGetProcAddress(WGPUDevice device, char const * procName);\n\n// Methods of Adapter\nWGPU_EXPORT WGPUDevice wgpuAdapterCreateDevice(WGPUAdapter adapter, WGPUDeviceDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT size_t wgpuAdapterEnumerateFeatures(WGPUAdapter adapter, WGPUFeatureName * features);\nWGPU_EXPORT bool wgpuAdapterGetLimits(WGPUAdapter adapter, WGPUSupportedLimits * limits);\nWGPU_EXPORT void wgpuAdapterGetProperties(WGPUAdapter adapter, WGPUAdapterProperties * properties);\nWGPU_EXPORT bool wgpuAdapterHasFeature(WGPUAdapter adapter, WGPUFeatureName feature);\nWGPU_EXPORT void wgpuAdapterRequestDevice(WGPUAdapter adapter, WGPUDeviceDescriptor const * descriptor /* nullable */, WGPURequestDeviceCallback callback, void * userdata);\nWGPU_EXPORT void wgpuAdapterReference(WGPUAdapter adapter);\nWGPU_EXPORT void wgpuAdapterRelease(WGPUAdapter adapter);\n\n// Methods of BindGroup\nWGPU_EXPORT void wgpuBindGroupSetLabel(WGPUBindGroup bindGroup, char const * label);\nWGPU_EXPORT void wgpuBindGroupReference(WGPUBindGroup bindGroup);\nWGPU_EXPORT void wgpuBindGroupRelease(WGPUBindGroup bindGroup);\n\n// Methods of BindGroupLayout\nWGPU_EXPORT void wgpuBindGroupLayoutSetLabel(WGPUBindGroupLayout bindGroupLayout, char const * label);\nWGPU_EXPORT void wgpuBindGroupLayoutReference(WGPUBindGroupLayout bindGroupLayout);\nWGPU_EXPORT void wgpuBindGroupLayoutRelease(WGPUBindGroupLayout bindGroupLayout);\n\n// Methods of Buffer\nWGPU_EXPORT void wgpuBufferDestroy(WGPUBuffer buffer);\nWGPU_EXPORT void const * wgpuBufferGetConstMappedRange(WGPUBuffer buffer, size_t offset, size_t size);\nWGPU_EXPORT WGPUBufferMapState wgpuBufferGetMapState(WGPUBuffer buffer);\nWGPU_EXPORT void * wgpuBufferGetMappedRange(WGPUBuffer buffer, size_t offset, size_t size);\nWGPU_EXPORT uint64_t wgpuBufferGetSize(WGPUBuffer buffer);\nWGPU_EXPORT WGPUBufferUsage wgpuBufferGetUsage(WGPUBuffer buffer);\nWGPU_EXPORT void wgpuBufferMapAsync(WGPUBuffer buffer, WGPUMapModeFlags mode, size_t offset, size_t size, WGPUBufferMapCallback callback, void * userdata);\nWGPU_EXPORT void wgpuBufferSetLabel(WGPUBuffer buffer, char const * label);\nWGPU_EXPORT void wgpuBufferUnmap(WGPUBuffer buffer);\nWGPU_EXPORT void wgpuBufferReference(WGPUBuffer buffer);\nWGPU_EXPORT void wgpuBufferRelease(WGPUBuffer buffer);\n\n// Methods of CommandBuffer\nWGPU_EXPORT void wgpuCommandBufferSetLabel(WGPUCommandBuffer commandBuffer, char const * label);\nWGPU_EXPORT void wgpuCommandBufferReference(WGPUCommandBuffer commandBuffer);\nWGPU_EXPORT void wgpuCommandBufferRelease(WGPUCommandBuffer commandBuffer);\n\n// Methods of CommandEncoder\nWGPU_EXPORT WGPUComputePassEncoder wgpuCommandEncoderBeginComputePass(WGPUCommandEncoder commandEncoder, WGPUComputePassDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT WGPURenderPassEncoder wgpuCommandEncoderBeginRenderPass(WGPUCommandEncoder commandEncoder, WGPURenderPassDescriptor const * descriptor);\nWGPU_EXPORT void wgpuCommandEncoderClearBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nWGPU_EXPORT void wgpuCommandEncoderCopyBufferToBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer source, uint64_t sourceOffset, WGPUBuffer destination, uint64_t destinationOffset, uint64_t size);\nWGPU_EXPORT void wgpuCommandEncoderCopyBufferToTexture(WGPUCommandEncoder commandEncoder, WGPUImageCopyBuffer const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToBuffer(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyBuffer const * destination, WGPUExtent3D const * copySize);\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToTexture(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nWGPU_EXPORT void wgpuCommandEncoderCopyTextureToTextureInternal(WGPUCommandEncoder commandEncoder, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize);\nWGPU_EXPORT WGPUCommandBuffer wgpuCommandEncoderFinish(WGPUCommandEncoder commandEncoder, WGPUCommandBufferDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT void wgpuCommandEncoderInjectValidationError(WGPUCommandEncoder commandEncoder, char const * message);\nWGPU_EXPORT void wgpuCommandEncoderInsertDebugMarker(WGPUCommandEncoder commandEncoder, char const * markerLabel);\nWGPU_EXPORT void wgpuCommandEncoderPopDebugGroup(WGPUCommandEncoder commandEncoder);\nWGPU_EXPORT void wgpuCommandEncoderPushDebugGroup(WGPUCommandEncoder commandEncoder, char const * groupLabel);\nWGPU_EXPORT void wgpuCommandEncoderResolveQuerySet(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t firstQuery, uint32_t queryCount, WGPUBuffer destination, uint64_t destinationOffset);\nWGPU_EXPORT void wgpuCommandEncoderSetLabel(WGPUCommandEncoder commandEncoder, char const * label);\nWGPU_EXPORT void wgpuCommandEncoderWriteBuffer(WGPUCommandEncoder commandEncoder, WGPUBuffer buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size);\nWGPU_EXPORT void wgpuCommandEncoderWriteTimestamp(WGPUCommandEncoder commandEncoder, WGPUQuerySet querySet, uint32_t queryIndex);\nWGPU_EXPORT void wgpuCommandEncoderReference(WGPUCommandEncoder commandEncoder);\nWGPU_EXPORT void wgpuCommandEncoderRelease(WGPUCommandEncoder commandEncoder);\n\n// Methods of ComputePassEncoder\nWGPU_EXPORT void wgpuComputePassEncoderDispatch(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\nWGPU_EXPORT void wgpuComputePassEncoderDispatchIndirect(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWGPU_EXPORT void wgpuComputePassEncoderDispatchWorkgroups(WGPUComputePassEncoder computePassEncoder, uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ);\nWGPU_EXPORT void wgpuComputePassEncoderDispatchWorkgroupsIndirect(WGPUComputePassEncoder computePassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWGPU_EXPORT void wgpuComputePassEncoderEnd(WGPUComputePassEncoder computePassEncoder);\nWGPU_EXPORT void wgpuComputePassEncoderEndPass(WGPUComputePassEncoder computePassEncoder);\nWGPU_EXPORT void wgpuComputePassEncoderInsertDebugMarker(WGPUComputePassEncoder computePassEncoder, char const * markerLabel);\nWGPU_EXPORT void wgpuComputePassEncoderPopDebugGroup(WGPUComputePassEncoder computePassEncoder);\nWGPU_EXPORT void wgpuComputePassEncoderPushDebugGroup(WGPUComputePassEncoder computePassEncoder, char const * groupLabel);\nWGPU_EXPORT void wgpuComputePassEncoderSetBindGroup(WGPUComputePassEncoder computePassEncoder, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nWGPU_EXPORT void wgpuComputePassEncoderSetLabel(WGPUComputePassEncoder computePassEncoder, char const * label);\nWGPU_EXPORT void wgpuComputePassEncoderSetPipeline(WGPUComputePassEncoder computePassEncoder, WGPUComputePipeline pipeline);\nWGPU_EXPORT void wgpuComputePassEncoderWriteTimestamp(WGPUComputePassEncoder computePassEncoder, WGPUQuerySet querySet, uint32_t queryIndex);\nWGPU_EXPORT void wgpuComputePassEncoderReference(WGPUComputePassEncoder computePassEncoder);\nWGPU_EXPORT void wgpuComputePassEncoderRelease(WGPUComputePassEncoder computePassEncoder);\n\n// Methods of ComputePipeline\nWGPU_EXPORT WGPUBindGroupLayout wgpuComputePipelineGetBindGroupLayout(WGPUComputePipeline computePipeline, uint32_t groupIndex);\nWGPU_EXPORT void wgpuComputePipelineSetLabel(WGPUComputePipeline computePipeline, char const * label);\nWGPU_EXPORT void wgpuComputePipelineReference(WGPUComputePipeline computePipeline);\nWGPU_EXPORT void wgpuComputePipelineRelease(WGPUComputePipeline computePipeline);\n\n// Methods of Device\nWGPU_EXPORT WGPUBindGroup wgpuDeviceCreateBindGroup(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor);\nWGPU_EXPORT WGPUBindGroupLayout wgpuDeviceCreateBindGroupLayout(WGPUDevice device, WGPUBindGroupLayoutDescriptor const * descriptor);\nWGPU_EXPORT WGPUBuffer wgpuDeviceCreateBuffer(WGPUDevice device, WGPUBufferDescriptor const * descriptor);\nWGPU_EXPORT WGPUCommandEncoder wgpuDeviceCreateCommandEncoder(WGPUDevice device, WGPUCommandEncoderDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT WGPUComputePipeline wgpuDeviceCreateComputePipeline(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor);\nWGPU_EXPORT void wgpuDeviceCreateComputePipelineAsync(WGPUDevice device, WGPUComputePipelineDescriptor const * descriptor, WGPUCreateComputePipelineAsyncCallback callback, void * userdata);\nWGPU_EXPORT WGPUBuffer wgpuDeviceCreateErrorBuffer(WGPUDevice device, WGPUBufferDescriptor const * descriptor);\nWGPU_EXPORT WGPUExternalTexture wgpuDeviceCreateErrorExternalTexture(WGPUDevice device);\nWGPU_EXPORT WGPUTexture wgpuDeviceCreateErrorTexture(WGPUDevice device, WGPUTextureDescriptor const * descriptor);\nWGPU_EXPORT WGPUExternalTexture wgpuDeviceCreateExternalTexture(WGPUDevice device, WGPUExternalTextureDescriptor const * externalTextureDescriptor);\nWGPU_EXPORT WGPUPipelineLayout wgpuDeviceCreatePipelineLayout(WGPUDevice device, WGPUPipelineLayoutDescriptor const * descriptor);\nWGPU_EXPORT WGPUQuerySet wgpuDeviceCreateQuerySet(WGPUDevice device, WGPUQuerySetDescriptor const * descriptor);\nWGPU_EXPORT WGPURenderBundleEncoder wgpuDeviceCreateRenderBundleEncoder(WGPUDevice device, WGPURenderBundleEncoderDescriptor const * descriptor);\nWGPU_EXPORT WGPURenderPipeline wgpuDeviceCreateRenderPipeline(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor);\nWGPU_EXPORT void wgpuDeviceCreateRenderPipelineAsync(WGPUDevice device, WGPURenderPipelineDescriptor const * descriptor, WGPUCreateRenderPipelineAsyncCallback callback, void * userdata);\nWGPU_EXPORT WGPUSampler wgpuDeviceCreateSampler(WGPUDevice device, WGPUSamplerDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT WGPUShaderModule wgpuDeviceCreateShaderModule(WGPUDevice device, WGPUShaderModuleDescriptor const * descriptor);\nWGPU_EXPORT WGPUSwapChain wgpuDeviceCreateSwapChain(WGPUDevice device, WGPUSurface surface /* nullable */, WGPUSwapChainDescriptor const * descriptor);\nWGPU_EXPORT WGPUTexture wgpuDeviceCreateTexture(WGPUDevice device, WGPUTextureDescriptor const * descriptor);\nWGPU_EXPORT void wgpuDeviceDestroy(WGPUDevice device);\nWGPU_EXPORT size_t wgpuDeviceEnumerateFeatures(WGPUDevice device, WGPUFeatureName * features);\nWGPU_EXPORT void wgpuDeviceForceLoss(WGPUDevice device, WGPUDeviceLostReason type, char const * message);\nWGPU_EXPORT WGPUAdapter wgpuDeviceGetAdapter(WGPUDevice device);\nWGPU_EXPORT bool wgpuDeviceGetLimits(WGPUDevice device, WGPUSupportedLimits * limits);\nWGPU_EXPORT WGPUQueue wgpuDeviceGetQueue(WGPUDevice device);\nWGPU_EXPORT bool wgpuDeviceHasFeature(WGPUDevice device, WGPUFeatureName feature);\nWGPU_EXPORT void wgpuDeviceInjectError(WGPUDevice device, WGPUErrorType type, char const * message);\nWGPU_EXPORT bool wgpuDevicePopErrorScope(WGPUDevice device, WGPUErrorCallback callback, void * userdata);\nWGPU_EXPORT void wgpuDevicePushErrorScope(WGPUDevice device, WGPUErrorFilter filter);\nWGPU_EXPORT void wgpuDeviceSetDeviceLostCallback(WGPUDevice device, WGPUDeviceLostCallback callback, void * userdata);\nWGPU_EXPORT void wgpuDeviceSetLabel(WGPUDevice device, char const * label);\nWGPU_EXPORT void wgpuDeviceSetLoggingCallback(WGPUDevice device, WGPULoggingCallback callback, void * userdata);\nWGPU_EXPORT void wgpuDeviceSetUncapturedErrorCallback(WGPUDevice device, WGPUErrorCallback callback, void * userdata);\nWGPU_EXPORT void wgpuDeviceTick(WGPUDevice device);\nWGPU_EXPORT void wgpuDeviceValidateTextureDescriptor(WGPUDevice device, WGPUTextureDescriptor const * descriptor);\nWGPU_EXPORT void wgpuDeviceReference(WGPUDevice device);\nWGPU_EXPORT void wgpuDeviceRelease(WGPUDevice device);\n\n// Methods of ExternalTexture\nWGPU_EXPORT void wgpuExternalTextureDestroy(WGPUExternalTexture externalTexture);\nWGPU_EXPORT void wgpuExternalTextureSetLabel(WGPUExternalTexture externalTexture, char const * label);\nWGPU_EXPORT void wgpuExternalTextureReference(WGPUExternalTexture externalTexture);\nWGPU_EXPORT void wgpuExternalTextureRelease(WGPUExternalTexture externalTexture);\n\n// Methods of Instance\nWGPU_EXPORT WGPUSurface wgpuInstanceCreateSurface(WGPUInstance instance, WGPUSurfaceDescriptor const * descriptor);\nWGPU_EXPORT void wgpuInstanceRequestAdapter(WGPUInstance instance, WGPURequestAdapterOptions const * options /* nullable */, WGPURequestAdapterCallback callback, void * userdata);\nWGPU_EXPORT void wgpuInstanceReference(WGPUInstance instance);\nWGPU_EXPORT void wgpuInstanceRelease(WGPUInstance instance);\n\n// Methods of PipelineLayout\nWGPU_EXPORT void wgpuPipelineLayoutSetLabel(WGPUPipelineLayout pipelineLayout, char const * label);\nWGPU_EXPORT void wgpuPipelineLayoutReference(WGPUPipelineLayout pipelineLayout);\nWGPU_EXPORT void wgpuPipelineLayoutRelease(WGPUPipelineLayout pipelineLayout);\n\n// Methods of QuerySet\nWGPU_EXPORT void wgpuQuerySetDestroy(WGPUQuerySet querySet);\nWGPU_EXPORT uint32_t wgpuQuerySetGetCount(WGPUQuerySet querySet);\nWGPU_EXPORT WGPUQueryType wgpuQuerySetGetType(WGPUQuerySet querySet);\nWGPU_EXPORT void wgpuQuerySetSetLabel(WGPUQuerySet querySet, char const * label);\nWGPU_EXPORT void wgpuQuerySetReference(WGPUQuerySet querySet);\nWGPU_EXPORT void wgpuQuerySetRelease(WGPUQuerySet querySet);\n\n// Methods of Queue\nWGPU_EXPORT void wgpuQueueCopyExternalTextureForBrowser(WGPUQueue queue, WGPUImageCopyExternalTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\nWGPU_EXPORT void wgpuQueueCopyTextureForBrowser(WGPUQueue queue, WGPUImageCopyTexture const * source, WGPUImageCopyTexture const * destination, WGPUExtent3D const * copySize, WGPUCopyTextureForBrowserOptions const * options);\nWGPU_EXPORT void wgpuQueueOnSubmittedWorkDone(WGPUQueue queue, uint64_t signalValue, WGPUQueueWorkDoneCallback callback, void * userdata);\nWGPU_EXPORT void wgpuQueueSetLabel(WGPUQueue queue, char const * label);\nWGPU_EXPORT void wgpuQueueSubmit(WGPUQueue queue, uint32_t commandCount, WGPUCommandBuffer const * commands);\nWGPU_EXPORT void wgpuQueueWriteBuffer(WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size);\nWGPU_EXPORT void wgpuQueueWriteTexture(WGPUQueue queue, WGPUImageCopyTexture const * destination, void const * data, size_t dataSize, WGPUTextureDataLayout const * dataLayout, WGPUExtent3D const * writeSize);\nWGPU_EXPORT void wgpuQueueReference(WGPUQueue queue);\nWGPU_EXPORT void wgpuQueueRelease(WGPUQueue queue);\n\n// Methods of RenderBundle\nWGPU_EXPORT void wgpuRenderBundleReference(WGPURenderBundle renderBundle);\nWGPU_EXPORT void wgpuRenderBundleRelease(WGPURenderBundle renderBundle);\n\n// Methods of RenderBundleEncoder\nWGPU_EXPORT void wgpuRenderBundleEncoderDraw(WGPURenderBundleEncoder renderBundleEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndexed(WGPURenderBundleEncoder renderBundleEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndexedIndirect(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWGPU_EXPORT void wgpuRenderBundleEncoderDrawIndirect(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWGPU_EXPORT WGPURenderBundle wgpuRenderBundleEncoderFinish(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderBundleDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT void wgpuRenderBundleEncoderInsertDebugMarker(WGPURenderBundleEncoder renderBundleEncoder, char const * markerLabel);\nWGPU_EXPORT void wgpuRenderBundleEncoderPopDebugGroup(WGPURenderBundleEncoder renderBundleEncoder);\nWGPU_EXPORT void wgpuRenderBundleEncoderPushDebugGroup(WGPURenderBundleEncoder renderBundleEncoder, char const * groupLabel);\nWGPU_EXPORT void wgpuRenderBundleEncoderSetBindGroup(WGPURenderBundleEncoder renderBundleEncoder, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nWGPU_EXPORT void wgpuRenderBundleEncoderSetIndexBuffer(WGPURenderBundleEncoder renderBundleEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\nWGPU_EXPORT void wgpuRenderBundleEncoderSetLabel(WGPURenderBundleEncoder renderBundleEncoder, char const * label);\nWGPU_EXPORT void wgpuRenderBundleEncoderSetPipeline(WGPURenderBundleEncoder renderBundleEncoder, WGPURenderPipeline pipeline);\nWGPU_EXPORT void wgpuRenderBundleEncoderSetVertexBuffer(WGPURenderBundleEncoder renderBundleEncoder, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nWGPU_EXPORT void wgpuRenderBundleEncoderReference(WGPURenderBundleEncoder renderBundleEncoder);\nWGPU_EXPORT void wgpuRenderBundleEncoderRelease(WGPURenderBundleEncoder renderBundleEncoder);\n\n// Methods of RenderPassEncoder\nWGPU_EXPORT void wgpuRenderPassEncoderBeginOcclusionQuery(WGPURenderPassEncoder renderPassEncoder, uint32_t queryIndex);\nWGPU_EXPORT void wgpuRenderPassEncoderDraw(WGPURenderPassEncoder renderPassEncoder, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndexed(WGPURenderPassEncoder renderPassEncoder, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance);\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndexedIndirect(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWGPU_EXPORT void wgpuRenderPassEncoderDrawIndirect(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer indirectBuffer, uint64_t indirectOffset);\nWGPU_EXPORT void wgpuRenderPassEncoderEnd(WGPURenderPassEncoder renderPassEncoder);\nWGPU_EXPORT void wgpuRenderPassEncoderEndOcclusionQuery(WGPURenderPassEncoder renderPassEncoder);\nWGPU_EXPORT void wgpuRenderPassEncoderEndPass(WGPURenderPassEncoder renderPassEncoder);\nWGPU_EXPORT void wgpuRenderPassEncoderExecuteBundles(WGPURenderPassEncoder renderPassEncoder, uint32_t bundleCount, WGPURenderBundle const * bundles);\nWGPU_EXPORT void wgpuRenderPassEncoderInsertDebugMarker(WGPURenderPassEncoder renderPassEncoder, char const * markerLabel);\nWGPU_EXPORT void wgpuRenderPassEncoderPopDebugGroup(WGPURenderPassEncoder renderPassEncoder);\nWGPU_EXPORT void wgpuRenderPassEncoderPushDebugGroup(WGPURenderPassEncoder renderPassEncoder, char const * groupLabel);\nWGPU_EXPORT void wgpuRenderPassEncoderSetBindGroup(WGPURenderPassEncoder renderPassEncoder, uint32_t groupIndex, WGPUBindGroup group, uint32_t dynamicOffsetCount, uint32_t const * dynamicOffsets);\nWGPU_EXPORT void wgpuRenderPassEncoderSetBlendConstant(WGPURenderPassEncoder renderPassEncoder, WGPUColor const * color);\nWGPU_EXPORT void wgpuRenderPassEncoderSetIndexBuffer(WGPURenderPassEncoder renderPassEncoder, WGPUBuffer buffer, WGPUIndexFormat format, uint64_t offset, uint64_t size);\nWGPU_EXPORT void wgpuRenderPassEncoderSetLabel(WGPURenderPassEncoder renderPassEncoder, char const * label);\nWGPU_EXPORT void wgpuRenderPassEncoderSetPipeline(WGPURenderPassEncoder renderPassEncoder, WGPURenderPipeline pipeline);\nWGPU_EXPORT void wgpuRenderPassEncoderSetScissorRect(WGPURenderPassEncoder renderPassEncoder, uint32_t x, uint32_t y, uint32_t width, uint32_t height);\nWGPU_EXPORT void wgpuRenderPassEncoderSetStencilReference(WGPURenderPassEncoder renderPassEncoder, uint32_t reference);\nWGPU_EXPORT void wgpuRenderPassEncoderSetVertexBuffer(WGPURenderPassEncoder renderPassEncoder, uint32_t slot, WGPUBuffer buffer, uint64_t offset, uint64_t size);\nWGPU_EXPORT void wgpuRenderPassEncoderSetViewport(WGPURenderPassEncoder renderPassEncoder, float x, float y, float width, float height, float minDepth, float maxDepth);\nWGPU_EXPORT void wgpuRenderPassEncoderWriteTimestamp(WGPURenderPassEncoder renderPassEncoder, WGPUQuerySet querySet, uint32_t queryIndex);\nWGPU_EXPORT void wgpuRenderPassEncoderReference(WGPURenderPassEncoder renderPassEncoder);\nWGPU_EXPORT void wgpuRenderPassEncoderRelease(WGPURenderPassEncoder renderPassEncoder);\n\n// Methods of RenderPipeline\nWGPU_EXPORT WGPUBindGroupLayout wgpuRenderPipelineGetBindGroupLayout(WGPURenderPipeline renderPipeline, uint32_t groupIndex);\nWGPU_EXPORT void wgpuRenderPipelineSetLabel(WGPURenderPipeline renderPipeline, char const * label);\nWGPU_EXPORT void wgpuRenderPipelineReference(WGPURenderPipeline renderPipeline);\nWGPU_EXPORT void wgpuRenderPipelineRelease(WGPURenderPipeline renderPipeline);\n\n// Methods of Sampler\nWGPU_EXPORT void wgpuSamplerSetLabel(WGPUSampler sampler, char const * label);\nWGPU_EXPORT void wgpuSamplerReference(WGPUSampler sampler);\nWGPU_EXPORT void wgpuSamplerRelease(WGPUSampler sampler);\n\n// Methods of ShaderModule\nWGPU_EXPORT void wgpuShaderModuleGetCompilationInfo(WGPUShaderModule shaderModule, WGPUCompilationInfoCallback callback, void * userdata);\nWGPU_EXPORT void wgpuShaderModuleSetLabel(WGPUShaderModule shaderModule, char const * label);\nWGPU_EXPORT void wgpuShaderModuleReference(WGPUShaderModule shaderModule);\nWGPU_EXPORT void wgpuShaderModuleRelease(WGPUShaderModule shaderModule);\n\n// Methods of Surface\nWGPU_EXPORT void wgpuSurfaceReference(WGPUSurface surface);\nWGPU_EXPORT void wgpuSurfaceRelease(WGPUSurface surface);\n\n// Methods of SwapChain\nWGPU_EXPORT void wgpuSwapChainConfigure(WGPUSwapChain swapChain, WGPUTextureFormat format, WGPUTextureUsageFlags allowedUsage, uint32_t width, uint32_t height);\nWGPU_EXPORT WGPUTextureView wgpuSwapChainGetCurrentTextureView(WGPUSwapChain swapChain);\nWGPU_EXPORT void wgpuSwapChainPresent(WGPUSwapChain swapChain);\nWGPU_EXPORT void wgpuSwapChainReference(WGPUSwapChain swapChain);\nWGPU_EXPORT void wgpuSwapChainRelease(WGPUSwapChain swapChain);\n\n// Methods of Texture\nWGPU_EXPORT WGPUTextureView wgpuTextureCreateView(WGPUTexture texture, WGPUTextureViewDescriptor const * descriptor /* nullable */);\nWGPU_EXPORT void wgpuTextureDestroy(WGPUTexture texture);\nWGPU_EXPORT uint32_t wgpuTextureGetDepthOrArrayLayers(WGPUTexture texture);\nWGPU_EXPORT WGPUTextureDimension wgpuTextureGetDimension(WGPUTexture texture);\nWGPU_EXPORT WGPUTextureFormat wgpuTextureGetFormat(WGPUTexture texture);\nWGPU_EXPORT uint32_t wgpuTextureGetHeight(WGPUTexture texture);\nWGPU_EXPORT uint32_t wgpuTextureGetMipLevelCount(WGPUTexture texture);\nWGPU_EXPORT uint32_t wgpuTextureGetSampleCount(WGPUTexture texture);\nWGPU_EXPORT WGPUTextureUsage wgpuTextureGetUsage(WGPUTexture texture);\nWGPU_EXPORT uint32_t wgpuTextureGetWidth(WGPUTexture texture);\nWGPU_EXPORT void wgpuTextureSetLabel(WGPUTexture texture, char const * label);\nWGPU_EXPORT void wgpuTextureReference(WGPUTexture texture);\nWGPU_EXPORT void wgpuTextureRelease(WGPUTexture texture);\n\n// Methods of TextureView\nWGPU_EXPORT void wgpuTextureViewSetLabel(WGPUTextureView textureView, char const * label);\nWGPU_EXPORT void wgpuTextureViewReference(WGPUTextureView textureView);\nWGPU_EXPORT void wgpuTextureViewRelease(WGPUTextureView textureView);\n\n#endif  // !defined(WGPU_SKIP_DECLARATIONS)\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif // WEBGPU_H_\n", "./include/dawn/wire/Wire.h": "// Copyright 2017 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_WIRE_H_\n#define INCLUDE_DAWN_WIRE_WIRE_H_\n\n#include <cstdint>\n#include <limits>\n\n#include \"dawn/webgpu.h\"\n#include \"dawn/wire/dawn_wire_export.h\"\n\nnamespace dawn::wire {\n\nclass DAWN_WIRE_EXPORT CommandSerializer {\n  public:\n    CommandSerializer();\n    virtual ~CommandSerializer();\n    CommandSerializer(const CommandSerializer& rhs) = delete;\n    CommandSerializer& operator=(const CommandSerializer& rhs) = delete;\n\n    // Get space for serializing commands.\n    // GetCmdSpace will never be called with a value larger than\n    // what GetMaximumAllocationSize returns. Return nullptr to indicate\n    // a fatal error.\n    virtual void* GetCmdSpace(size_t size) = 0;\n    virtual bool Flush() = 0;\n    virtual size_t GetMaximumAllocationSize() const = 0;\n    virtual void OnSerializeError();\n};\n\nclass DAWN_WIRE_EXPORT CommandHandler {\n  public:\n    CommandHandler();\n    virtual ~CommandHandler();\n    CommandHandler(const CommandHandler& rhs) = delete;\n    CommandHandler& operator=(const CommandHandler& rhs) = delete;\n\n    virtual const volatile char* HandleCommands(const volatile char* commands, size_t size) = 0;\n};\n\n}  // namespace dawn::wire\n\n// TODO(dawn:824): Remove once the deprecation period is passed.\nnamespace dawn_wire = dawn::wire;\n\n#endif  // INCLUDE_DAWN_WIRE_WIRE_H_\n", "./include/dawn/wire/WireServer.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_WIRESERVER_H_\n#define INCLUDE_DAWN_WIRE_WIRESERVER_H_\n\n#include <memory>\n\n#include \"dawn/wire/Wire.h\"\n\nstruct DawnProcTable;\n\nnamespace dawn::wire {\n\nnamespace server {\nclass Server;\nclass MemoryTransferService;\n}  // namespace server\n\nstruct DAWN_WIRE_EXPORT WireServerDescriptor {\n    const DawnProcTable* procs;\n    CommandSerializer* serializer;\n    server::MemoryTransferService* memoryTransferService = nullptr;\n};\n\nclass DAWN_WIRE_EXPORT WireServer : public CommandHandler {\n  public:\n    explicit WireServer(const WireServerDescriptor& descriptor);\n    ~WireServer() override;\n\n    const volatile char* HandleCommands(const volatile char* commands, size_t size) override;\n\n    bool InjectTexture(WGPUTexture texture,\n                       uint32_t id,\n                       uint32_t generation,\n                       uint32_t deviceId,\n                       uint32_t deviceGeneration);\n    bool InjectSwapChain(WGPUSwapChain swapchain,\n                         uint32_t id,\n                         uint32_t generation,\n                         uint32_t deviceId,\n                         uint32_t deviceGeneration);\n\n    bool InjectDevice(WGPUDevice device, uint32_t id, uint32_t generation);\n\n    bool InjectInstance(WGPUInstance instance, uint32_t id, uint32_t generation);\n\n    // Look up a device by (id, generation) pair. Returns nullptr if the generation\n    // has expired or the id is not found.\n    // The Wire does not have destroy hooks to allow an embedder to observe when an object\n    // has been destroyed, but in Chrome, we need to know the list of live devices so we\n    // can call device.Tick() on all of them periodically to ensure progress on asynchronous\n    // work is made. Getting this list can be done by tracking the (id, generation) of\n    // previously injected devices, and observing if GetDevice(id, generation) returns non-null.\n    WGPUDevice GetDevice(uint32_t id, uint32_t generation);\n\n    // Check if a device handle is known by the wire.\n    // In Chrome, we need to know the list of live devices so we can call device.Tick() on all of\n    // them periodically to ensure progress on asynchronous work is made.\n    bool IsDeviceKnown(WGPUDevice device) const;\n\n  private:\n    std::unique_ptr<server::Server> mImpl;\n};\n\nnamespace server {\nclass DAWN_WIRE_EXPORT MemoryTransferService {\n  public:\n    MemoryTransferService();\n    virtual ~MemoryTransferService();\n\n    class ReadHandle;\n    class WriteHandle;\n\n    // Deserialize data to create Read/Write handles. These handles are for the client\n    // to Read/Write data.\n    virtual bool DeserializeReadHandle(const void* deserializePointer,\n                                       size_t deserializeSize,\n                                       ReadHandle** readHandle) = 0;\n    virtual bool DeserializeWriteHandle(const void* deserializePointer,\n                                        size_t deserializeSize,\n                                        WriteHandle** writeHandle) = 0;\n\n    class DAWN_WIRE_EXPORT ReadHandle {\n      public:\n        ReadHandle();\n        virtual ~ReadHandle();\n\n        // Return the size of the command serialized if\n        // SerializeDataUpdate is called with the same offset/size args\n        virtual size_t SizeOfSerializeDataUpdate(size_t offset, size_t size) = 0;\n\n        // Gets called when a MapReadCallback resolves.\n        // Serialize the data update for the range (offset, offset + size) into\n        // |serializePointer| to the client There could be nothing to be serialized (if\n        // using shared memory)\n        virtual void SerializeDataUpdate(const void* data,\n                                         size_t offset,\n                                         size_t size,\n                                         void* serializePointer) = 0;\n\n      private:\n        ReadHandle(const ReadHandle&) = delete;\n        ReadHandle& operator=(const ReadHandle&) = delete;\n    };\n\n    class DAWN_WIRE_EXPORT WriteHandle {\n      public:\n        WriteHandle();\n        virtual ~WriteHandle();\n\n        // Set the target for writes from the client. DeserializeFlush should copy data\n        // into the target.\n        void SetTarget(void* data);\n        // Set Staging data length for OOB check\n        void SetDataLength(size_t dataLength);\n\n        // This function takes in the serialized result of\n        // client::MemoryTransferService::WriteHandle::SerializeDataUpdate.\n        // Needs to check potential offset/size OOB and overflow\n        virtual bool DeserializeDataUpdate(const void* deserializePointer,\n                                           size_t deserializeSize,\n                                           size_t offset,\n                                           size_t size) = 0;\n\n      protected:\n        void* mTargetData = nullptr;\n        size_t mDataLength = 0;\n\n      private:\n        WriteHandle(const WriteHandle&) = delete;\n        WriteHandle& operator=(const WriteHandle&) = delete;\n    };\n\n  private:\n    MemoryTransferService(const MemoryTransferService&) = delete;\n    MemoryTransferService& operator=(const MemoryTransferService&) = delete;\n};\n}  // namespace server\n\n}  // namespace dawn::wire\n\n#endif  // INCLUDE_DAWN_WIRE_WIRESERVER_H_\n", "./include/dawn/wire/dawn_wire_export.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_DAWN_WIRE_EXPORT_H_\n#define INCLUDE_DAWN_WIRE_DAWN_WIRE_EXPORT_H_\n\n#if defined(DAWN_WIRE_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(DAWN_WIRE_IMPLEMENTATION)\n#define DAWN_WIRE_EXPORT __declspec(dllexport)\n#else\n#define DAWN_WIRE_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(DAWN_WIRE_IMPLEMENTATION)\n#define DAWN_WIRE_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define DAWN_WIRE_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(DAWN_WIRE_SHARED_LIBRARY)\n#define DAWN_WIRE_EXPORT\n#endif  // defined(DAWN_WIRE_SHARED_LIBRARY)\n\n#endif  // INCLUDE_DAWN_WIRE_DAWN_WIRE_EXPORT_H_\n", "./include/dawn/wire/WireClient.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_WIRE_WIRECLIENT_H_\n#define INCLUDE_DAWN_WIRE_WIRECLIENT_H_\n\n#include <memory>\n#include <vector>\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/wire/Wire.h\"\n\nnamespace dawn::wire {\n\nnamespace client {\nclass Client;\nclass MemoryTransferService;\n\nDAWN_WIRE_EXPORT const DawnProcTable& GetProcs();\n}  // namespace client\n\nstruct ReservedTexture {\n    WGPUTexture texture;\n    uint32_t id;\n    uint32_t generation;\n    uint32_t deviceId;\n    uint32_t deviceGeneration;\n};\n\nstruct ReservedSwapChain {\n    WGPUSwapChain swapchain;\n    uint32_t id;\n    uint32_t generation;\n    uint32_t deviceId;\n    uint32_t deviceGeneration;\n};\n\nstruct ReservedDevice {\n    WGPUDevice device;\n    uint32_t id;\n    uint32_t generation;\n};\n\nstruct ReservedInstance {\n    WGPUInstance instance;\n    uint32_t id;\n    uint32_t generation;\n};\n\nstruct DAWN_WIRE_EXPORT WireClientDescriptor {\n    CommandSerializer* serializer;\n    client::MemoryTransferService* memoryTransferService = nullptr;\n};\n\nclass DAWN_WIRE_EXPORT WireClient : public CommandHandler {\n  public:\n    explicit WireClient(const WireClientDescriptor& descriptor);\n    ~WireClient() override;\n\n    const volatile char* HandleCommands(const volatile char* commands, size_t size) override;\n\n    ReservedTexture ReserveTexture(WGPUDevice device, const WGPUTextureDescriptor* descriptor);\n    ReservedSwapChain ReserveSwapChain(WGPUDevice device);\n    ReservedDevice ReserveDevice();\n    ReservedInstance ReserveInstance();\n\n    void ReclaimTextureReservation(const ReservedTexture& reservation);\n    void ReclaimSwapChainReservation(const ReservedSwapChain& reservation);\n    void ReclaimDeviceReservation(const ReservedDevice& reservation);\n    void ReclaimInstanceReservation(const ReservedInstance& reservation);\n\n    // Disconnects the client.\n    // Commands allocated after this point will not be sent.\n    void Disconnect();\n\n  private:\n    std::unique_ptr<client::Client> mImpl;\n};\n\nnamespace client {\nclass DAWN_WIRE_EXPORT MemoryTransferService {\n  public:\n    MemoryTransferService();\n    virtual ~MemoryTransferService();\n\n    class ReadHandle;\n    class WriteHandle;\n\n    // Create a handle for reading server data.\n    // This may fail and return nullptr.\n    virtual ReadHandle* CreateReadHandle(size_t) = 0;\n\n    // Create a handle for writing server data.\n    // This may fail and return nullptr.\n    virtual WriteHandle* CreateWriteHandle(size_t) = 0;\n\n    class DAWN_WIRE_EXPORT ReadHandle {\n      public:\n        ReadHandle();\n        virtual ~ReadHandle();\n\n        // Get the required serialization size for SerializeCreate\n        virtual size_t SerializeCreateSize() = 0;\n\n        // Serialize the handle into |serializePointer| so it can be received by the server.\n        virtual void SerializeCreate(void* serializePointer) = 0;\n\n        // Simply return the base address of the allocation (without applying any offset)\n        // Returns nullptr if the allocation failed.\n        // The data must live at least until the ReadHandle is destructued\n        virtual const void* GetData() = 0;\n\n        // Gets called when a MapReadCallback resolves.\n        // deserialize the data update and apply\n        // it to the range (offset, offset + size) of allocation\n        // There could be nothing to be deserialized (if using shared memory)\n        // Needs to check potential offset/size OOB and overflow\n        virtual bool DeserializeDataUpdate(const void* deserializePointer,\n                                           size_t deserializeSize,\n                                           size_t offset,\n                                           size_t size) = 0;\n\n      private:\n        ReadHandle(const ReadHandle&) = delete;\n        ReadHandle& operator=(const ReadHandle&) = delete;\n    };\n\n    class DAWN_WIRE_EXPORT WriteHandle {\n      public:\n        WriteHandle();\n        virtual ~WriteHandle();\n\n        // Get the required serialization size for SerializeCreate\n        virtual size_t SerializeCreateSize() = 0;\n\n        // Serialize the handle into |serializePointer| so it can be received by the server.\n        virtual void SerializeCreate(void* serializePointer) = 0;\n\n        // Simply return the base address of the allocation (without applying any offset)\n        // The data returned should be zero-initialized.\n        // The data returned must live at least until the WriteHandle is destructed.\n        // On failure, the pointer returned should be null.\n        virtual void* GetData() = 0;\n\n        // Get the required serialization size for SerializeDataUpdate\n        virtual size_t SizeOfSerializeDataUpdate(size_t offset, size_t size) = 0;\n\n        // Serialize a command to send the modified contents of\n        // the subrange (offset, offset + size) of the allocation at buffer unmap\n        // This subrange is always the whole mapped region for now\n        // There could be nothing to be serialized (if using shared memory)\n        virtual void SerializeDataUpdate(void* serializePointer, size_t offset, size_t size) = 0;\n\n      private:\n        WriteHandle(const WriteHandle&) = delete;\n        WriteHandle& operator=(const WriteHandle&) = delete;\n    };\n\n  private:\n    MemoryTransferService(const MemoryTransferService&) = delete;\n    MemoryTransferService& operator=(const MemoryTransferService&) = delete;\n};\n\n// Backdoor to get the order of the ProcMap for testing\nDAWN_WIRE_EXPORT std::vector<const char*> GetProcMapNamesForTesting();\n}  // namespace client\n}  // namespace dawn::wire\n\n#endif  // INCLUDE_DAWN_WIRE_WIRECLIENT_H_\n", "./include/dawn/native/VulkanBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_VULKANBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_VULKANBACKEND_H_\n\n#include <vulkan/vulkan.h>\n\n#include <array>\n#include <vector>\n\n#include \"dawn/dawn_wsi.h\"\n#include \"dawn/native/DawnNative.h\"\n\nnamespace dawn::native::vulkan {\n\nDAWN_NATIVE_EXPORT VkInstance GetInstance(WGPUDevice device);\n\nDAWN_NATIVE_EXPORT PFN_vkVoidFunction GetInstanceProcAddr(WGPUDevice device, const char* pName);\n\nDAWN_NATIVE_EXPORT DawnSwapChainImplementation CreateNativeSwapChainImpl(WGPUDevice device,\n                                                                         ::VkSurfaceKHR surface);\nDAWN_NATIVE_EXPORT WGPUTextureFormat\nGetNativeSwapChainPreferredFormat(const DawnSwapChainImplementation* swapChain);\n\nstruct DAWN_NATIVE_EXPORT AdapterDiscoveryOptions : public AdapterDiscoveryOptionsBase {\n    AdapterDiscoveryOptions();\n\n    bool forceSwiftShader = false;\n};\n\nenum class NeedsDedicatedAllocation {\n    Yes,\n    No,\n    // Use Vulkan reflection to detect whether a dedicated allocation is needed.\n    Detect,\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorVk : ExternalImageDescriptor {\n  public:\n    // The following members may be ignored if |ExternalImageDescriptor::isInitialized| is false\n    // since the import does not need to preserve texture contents.\n\n    // See https://www.khronos.org/registry/vulkan/specs/1.1/html/chap7.html. The acquire\n    // operation old/new layouts must match exactly the layouts in the release operation. So\n    // we may need to issue two barriers releasedOldLayout -> releasedNewLayout ->\n    // cTextureDescriptor.usage if the new layout is not compatible with the desired usage.\n    // The first barrier is the queue transfer, the second is the layout transition to our\n    // desired usage.\n    VkImageLayout releasedOldLayout = VK_IMAGE_LAYOUT_GENERAL;\n    VkImageLayout releasedNewLayout = VK_IMAGE_LAYOUT_GENERAL;\n\n    // Try to detect the need to use a dedicated allocation for imported images by default but let\n    // the application override this as drivers have bugs and forget to require a dedicated\n    // allocation.\n    NeedsDedicatedAllocation dedicatedAllocation = NeedsDedicatedAllocation::Detect;\n\n  protected:\n    using ExternalImageDescriptor::ExternalImageDescriptor;\n};\n\nstruct ExternalImageExportInfoVk : ExternalImageExportInfo {\n  public:\n    // See comments in |ExternalImageDescriptorVk|\n    // Contains the old/new layouts used in the queue release operation.\n    VkImageLayout releasedOldLayout;\n    VkImageLayout releasedNewLayout;\n\n  protected:\n    using ExternalImageExportInfo::ExternalImageExportInfo;\n};\n\n// Can't use DAWN_PLATFORM_IS(LINUX) since header included in both Dawn and Chrome\n#ifdef __linux__\n\n// Common properties of external images represented by FDs. On successful import the file\n// descriptor's ownership is transferred to the Dawn implementation and they shouldn't be\n// used outside of Dawn again. TODO(enga): Also transfer ownership in the error case so the\n// caller can assume the FD is always consumed.\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorFD : ExternalImageDescriptorVk {\n  public:\n    int memoryFD;              // A file descriptor from an export of the memory of the image\n    std::vector<int> waitFDs;  // File descriptors of semaphores which will be waited on\n\n  protected:\n    using ExternalImageDescriptorVk::ExternalImageDescriptorVk;\n};\n\n// Descriptor for opaque file descriptor image import\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorOpaqueFD : ExternalImageDescriptorFD {\n    ExternalImageDescriptorOpaqueFD();\n\n    VkDeviceSize allocationSize;  // Must match VkMemoryAllocateInfo from image creation\n    uint32_t memoryTypeIndex;     // Must match VkMemoryAllocateInfo from image creation\n};\n\n// The plane-wise offset and stride.\nstruct DAWN_NATIVE_EXPORT PlaneLayout {\n    uint64_t offset;\n    uint32_t stride;\n};\n\n// Descriptor for dma-buf file descriptor image import\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorDmaBuf : ExternalImageDescriptorFD {\n    ExternalImageDescriptorDmaBuf();\n\n    static constexpr uint32_t kMaxPlanes = 3;\n    std::array<PlaneLayout, kMaxPlanes> planeLayouts;\n    uint64_t drmModifier;  // DRM modifier of the buffer\n};\n\n// Info struct that is written to in |ExportVulkanImage|.\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoFD : ExternalImageExportInfoVk {\n  public:\n    // Contains the exported semaphore handles.\n    std::vector<int> semaphoreHandles;\n\n  protected:\n    using ExternalImageExportInfoVk::ExternalImageExportInfoVk;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoOpaqueFD : ExternalImageExportInfoFD {\n    ExternalImageExportInfoOpaqueFD();\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoDmaBuf : ExternalImageExportInfoFD {\n    ExternalImageExportInfoDmaBuf();\n};\n\n#ifdef __ANDROID__\n\n// Descriptor for AHardwareBuffer image import\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorAHardwareBuffer : ExternalImageDescriptorVk {\n  public:\n    ExternalImageDescriptorAHardwareBuffer();\n\n    struct AHardwareBuffer* handle;  // The AHardwareBuffer which contains the memory of the image\n    std::vector<int> waitFDs;        // File descriptors of semaphores which will be waited on\n\n  protected:\n    using ExternalImageDescriptorVk::ExternalImageDescriptorVk;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfoAHardwareBuffer : ExternalImageExportInfoFD {\n    ExternalImageExportInfoAHardwareBuffer();\n};\n\n#endif  // __ANDROID__\n\n#endif  // __linux__\n\n// Imports external memory into a Vulkan image. Internally, this uses external memory /\n// semaphore extensions to import the image and wait on the provided synchronizaton\n// primitives before the texture can be used.\n// On failure, returns a nullptr.\nDAWN_NATIVE_EXPORT WGPUTexture WrapVulkanImage(WGPUDevice device,\n                                               const ExternalImageDescriptorVk* descriptor);\n\n// Exports external memory from a Vulkan image. This must be called on wrapped textures\n// before they are destroyed. It writes the semaphore to wait on and the old/new image\n// layouts to |info|. Pass VK_IMAGE_LAYOUT_UNDEFINED as |desiredLayout| if you don't want to\n// perform a layout transition.\nDAWN_NATIVE_EXPORT bool ExportVulkanImage(WGPUTexture texture,\n                                          VkImageLayout desiredLayout,\n                                          ExternalImageExportInfoVk* info);\n// |ExportVulkanImage| with default desiredLayout of VK_IMAGE_LAYOUT_UNDEFINED.\nDAWN_NATIVE_EXPORT bool ExportVulkanImage(WGPUTexture texture, ExternalImageExportInfoVk* info);\n\n}  // namespace dawn::native::vulkan\n\n#endif  // INCLUDE_DAWN_NATIVE_VULKANBACKEND_H_\n", "./include/dawn/native/NullBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_NULLBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_NULLBACKEND_H_\n\n#include \"dawn/dawn_wsi.h\"\n#include \"dawn/native/DawnNative.h\"\n\nnamespace dawn::native::null {\nDAWN_NATIVE_EXPORT DawnSwapChainImplementation CreateNativeSwapChainImpl();\n}  // namespace dawn::native::null\n\n#endif  // INCLUDE_DAWN_NATIVE_NULLBACKEND_H_\n", "./include/dawn/native/dawn_native_export.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_DAWN_NATIVE_EXPORT_H_\n#define INCLUDE_DAWN_NATIVE_DAWN_NATIVE_EXPORT_H_\n\n#if defined(DAWN_NATIVE_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(DAWN_NATIVE_IMPLEMENTATION)\n#define DAWN_NATIVE_EXPORT __declspec(dllexport)\n#else\n#define DAWN_NATIVE_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(DAWN_NATIVE_IMPLEMENTATION)\n#define DAWN_NATIVE_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define DAWN_NATIVE_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(DAWN_NATIVE_SHARED_LIBRARY)\n#define DAWN_NATIVE_EXPORT\n#endif  // defined(DAWN_NATIVE_SHARED_LIBRARY)\n\n#endif  // INCLUDE_DAWN_NATIVE_DAWN_NATIVE_EXPORT_H_\n", "./include/dawn/native/D3D12Backend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_D3D12BACKEND_H_\n#define INCLUDE_DAWN_NATIVE_D3D12BACKEND_H_\n\n#include <DXGI1_4.h>\n#include <d3d12.h>\n#include <windows.h>\n#include <wrl/client.h>\n\n#include <memory>\n#include <vector>\n\n#include \"dawn/dawn_wsi.h\"\n#include \"dawn/native/DawnNative.h\"\n\nstruct ID3D12Device;\nstruct ID3D12Resource;\n\nnamespace dawn::native::d3d12 {\n\nclass D3D11on12ResourceCache;\nclass Device;\nclass ExternalImageDXGIImpl;\n\nDAWN_NATIVE_EXPORT Microsoft::WRL::ComPtr<ID3D12Device> GetD3D12Device(WGPUDevice device);\nDAWN_NATIVE_EXPORT DawnSwapChainImplementation CreateNativeSwapChainImpl(WGPUDevice device,\n                                                                         HWND window);\nDAWN_NATIVE_EXPORT WGPUTextureFormat\nGetNativeSwapChainPreferredFormat(const DawnSwapChainImplementation* swapChain);\n\nenum MemorySegment {\n    Local,\n    NonLocal,\n};\n\nDAWN_NATIVE_EXPORT uint64_t SetExternalMemoryReservation(WGPUDevice device,\n                                                         uint64_t requestedReservationSize,\n                                                         MemorySegment memorySegment);\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorDXGISharedHandle : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorDXGISharedHandle();\n\n    // Note: SharedHandle must be a handle to a texture object.\n    HANDLE sharedHandle = nullptr;\n\n    // Whether fence synchronization should be used instead of texture's keyed mutex.\n    bool useFenceSynchronization = false;\n};\n\n// Keyed mutex acquire/release uses a fixed key of 0 to match Chromium behavior.\nconstexpr UINT64 kDXGIKeyedMutexAcquireReleaseKey = 0;\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDXGIFenceDescriptor {\n    // Shared handle for the fence. This never passes ownership to the callee (when used as an input\n    // parameter) or to the caller (when used as a return value or output parameter).\n    HANDLE fenceHandle = nullptr;\n\n    // The value that was previously signaled on this fence and should be waited on.\n    uint64_t fenceValue = 0;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDXGIBeginAccessDescriptor {\n    bool isInitialized = false;  // Whether the texture is initialized on import\n    WGPUTextureUsageFlags usage = WGPUTextureUsage_None;\n\n    // A list of fences to wait on before accessing the texture.\n    std::vector<ExternalImageDXGIFenceDescriptor> waitFences;\n\n    // Whether the texture is for a WebGPU swap chain.\n    bool isSwapChainTexture = false;\n};\n\n// TODO(dawn:576): Remove after changing Chromium code to use the new struct name.\nstruct DAWN_NATIVE_EXPORT ExternalImageAccessDescriptorDXGIKeyedMutex\n    : ExternalImageDXGIBeginAccessDescriptor {\n  public:\n    // TODO(chromium:1241533): Remove deprecated keyed mutex params after removing associated\n    // code from Chromium - we use a fixed key of 0 for acquire and release everywhere now.\n    uint64_t acquireMutexKey;\n    uint64_t releaseMutexKey;\n};\n\nclass DAWN_NATIVE_EXPORT ExternalImageDXGI {\n  public:\n    ~ExternalImageDXGI();\n\n    static std::unique_ptr<ExternalImageDXGI> Create(\n        WGPUDevice device,\n        const ExternalImageDescriptorDXGISharedHandle* descriptor);\n\n    // Returns true if the external image resources are still valid, otherwise ProduceTexture() is\n    // guaranteed to fail e.g. after device destruction.\n    bool IsValid() const;\n\n    // TODO(sunnyps): |device| is ignored - remove after Chromium migrates to BeginAccess().\n    WGPUTexture ProduceTexture(WGPUDevice device,\n                               const ExternalImageDXGIBeginAccessDescriptor* descriptor);\n\n    // Creates WGPUTexture wrapping the DXGI shared handle. The provided wait fences or the\n    // texture's keyed mutex will be synchronized before using the texture in any command lists.\n    // Empty fences (nullptr handle) are ignored for convenience (EndAccess can return such fences).\n    WGPUTexture BeginAccess(const ExternalImageDXGIBeginAccessDescriptor* descriptor);\n\n    // Returns the signalFence that the client must wait on for correct synchronization. Can return\n    // an empty fence (nullptr handle) if the texture wasn't accessed by Dawn.\n    // Note that merely calling Destroy() on the WGPUTexture does not ensure synchronization.\n    void EndAccess(WGPUTexture texture, ExternalImageDXGIFenceDescriptor* signalFence);\n\n  private:\n    explicit ExternalImageDXGI(std::unique_ptr<ExternalImageDXGIImpl> impl);\n\n    std::unique_ptr<ExternalImageDXGIImpl> mImpl;\n};\n\nstruct DAWN_NATIVE_EXPORT AdapterDiscoveryOptions : public AdapterDiscoveryOptionsBase {\n    AdapterDiscoveryOptions();\n    explicit AdapterDiscoveryOptions(Microsoft::WRL::ComPtr<IDXGIAdapter> adapter);\n\n    Microsoft::WRL::ComPtr<IDXGIAdapter> dxgiAdapter;\n};\n\n}  // namespace dawn::native::d3d12\n\n#endif  // INCLUDE_DAWN_NATIVE_D3D12BACKEND_H_\n", "./include/dawn/native/MetalBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_METALBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_METALBACKEND_H_\n\n#include <vector>\n\n#include \"dawn/dawn_wsi.h\"\n#include \"dawn/native/DawnNative.h\"\n\n// The specifics of the Metal backend expose types in function signatures that might not be\n// available in dependent's minimum supported SDK version. Suppress all availability errors using\n// clang's pragmas. Dependents using the types without guarded availability will still get errors\n// when using the types.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunguarded-availability\"\n\nstruct __IOSurface;\ntypedef __IOSurface* IOSurfaceRef;\n\n#ifdef __OBJC__\n#import <Metal/Metal.h>\n#endif  // __OBJC__\n\nnamespace dawn::native::metal {\n\nstruct DAWN_NATIVE_EXPORT AdapterDiscoveryOptions : public AdapterDiscoveryOptionsBase {\n    AdapterDiscoveryOptions();\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageMTLSharedEventDescriptor {\n    // Shared event handle `id<MTLSharedEvent>`.\n    // This never passes ownership to the callee (when used as an input\n    // parameter) or to the caller (when used as a return value or output parameter).\n#ifdef __OBJC__\n    id<MTLSharedEvent> sharedEvent = nil;\n    static_assert(sizeof(id<MTLSharedEvent>) == sizeof(void*));\n    static_assert(alignof(id<MTLSharedEvent>) == alignof(void*));\n#else\n    void* sharedEvent = nullptr;\n#endif\n\n    // The value that was previously signaled on this event and should be waited on.\n    uint64_t signaledValue = 0;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorIOSurface : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorIOSurface();\n    ~ExternalImageDescriptorIOSurface();\n\n    IOSurfaceRef ioSurface;\n\n    // This has been deprecated.\n    uint32_t plane;\n\n    // A list of events to wait on before accessing the texture.\n    std::vector<ExternalImageMTLSharedEventDescriptor> waitEvents;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageIOSurfaceEndAccessDescriptor\n    : ExternalImageMTLSharedEventDescriptor {\n    bool isInitialized;\n};\n\nDAWN_NATIVE_EXPORT WGPUTexture WrapIOSurface(WGPUDevice device,\n                                             const ExternalImageDescriptorIOSurface* descriptor);\n\nDAWN_NATIVE_EXPORT void IOSurfaceEndAccess(WGPUTexture texture,\n                                           ExternalImageIOSurfaceEndAccessDescriptor* descriptor);\n\n// When making Metal interop with other APIs, we need to be careful that QueueSubmit doesn't\n// mean that the operations will be visible to other APIs/Metal devices right away. macOS\n// does have a global queue of graphics operations, but the command buffers are inserted there\n// when they are \"scheduled\". Submitting other operations before the command buffer is\n// scheduled could lead to races in who gets scheduled first and incorrect rendering.\nDAWN_NATIVE_EXPORT void WaitForCommandsToBeScheduled(WGPUDevice device);\n\n}  // namespace dawn::native::metal\n\n#pragma clang diagnostic pop\n\n#endif  // INCLUDE_DAWN_NATIVE_METALBACKEND_H_\n", "./include/dawn/native/DawnNative.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_DAWNNATIVE_H_\n#define INCLUDE_DAWN_NATIVE_DAWNNATIVE_H_\n\n#include <string>\n#include <vector>\n\n#include \"dawn/dawn_proc_table.h\"\n#include \"dawn/native/dawn_native_export.h\"\n#include \"dawn/webgpu.h\"\n\nnamespace dawn::platform {\nclass Platform;\n}  // namespace dawn::platform\n\nnamespace wgpu {\nstruct AdapterProperties;\nstruct DeviceDescriptor;\n}  // namespace wgpu\n\nnamespace dawn::native {\n\nclass InstanceBase;\nclass AdapterBase;\n\n// An optional parameter of Adapter::CreateDevice() to send additional information when creating\n// a Device. For example, we can use it to enable a workaround, optimization or feature.\nstruct DAWN_NATIVE_EXPORT DawnDeviceDescriptor {\n    DawnDeviceDescriptor();\n    ~DawnDeviceDescriptor();\n\n    std::vector<const char*> requiredFeatures;\n    std::vector<const char*> forceEnabledToggles;\n    std::vector<const char*> forceDisabledToggles;\n\n    const WGPURequiredLimits* requiredLimits = nullptr;\n};\n\n// A struct to record the information of a toggle. A toggle is a code path in Dawn device that\n// can be manually configured to run or not outside Dawn, including workarounds, special\n// features and optimizations.\nstruct ToggleInfo {\n    const char* name;\n    const char* description;\n    const char* url;\n};\n\n// A struct to record the information of a feature. A feature is a GPU feature that is not\n// required to be supported by all Dawn backends and can only be used when it is enabled on the\n// creation of device.\nstruct FeatureInfo {\n    const char* name;\n    const char* description;\n    const char* url;\n    // The enum of feature state, could be stable or experimental. Using an experimental feature\n    // requires DisallowUnsafeAPIs toggle being disabled.\n    enum class FeatureState { Stable = 0, Experimental };\n    FeatureState featureState;\n};\n\n// An adapter is an object that represent on possibility of creating devices in the system.\n// Most of the time it will represent a combination of a physical GPU and an API. Not that the\n// same GPU can be represented by multiple adapters but on different APIs.\n//\n// The underlying Dawn adapter is owned by the Dawn instance so this class is not RAII but just\n// a reference to an underlying adapter.\nclass DAWN_NATIVE_EXPORT Adapter {\n  public:\n    Adapter();\n    // NOLINTNEXTLINE(runtime/explicit)\n    Adapter(AdapterBase* impl);\n    ~Adapter();\n\n    Adapter(const Adapter& other);\n    Adapter& operator=(const Adapter& other);\n\n    // Essentially webgpu.h's wgpuAdapterGetProperties while we don't have WGPUAdapter in\n    // dawn.json\n    void GetProperties(wgpu::AdapterProperties* properties) const;\n    void GetProperties(WGPUAdapterProperties* properties) const;\n\n    std::vector<const char*> GetSupportedExtensions() const;\n    std::vector<const char*> GetSupportedFeatures() const;\n    bool GetLimits(WGPUSupportedLimits* limits) const;\n\n    void SetUseTieredLimits(bool useTieredLimits);\n\n    // Check that the Adapter is able to support importing external images. This is necessary\n    // to implement the swapchain and interop APIs in Chromium.\n    bool SupportsExternalImages() const;\n\n    explicit operator bool() const;\n\n    // Create a device on this adapter. On an error, nullptr is returned.\n    WGPUDevice CreateDevice(const DawnDeviceDescriptor* deviceDescriptor);\n    WGPUDevice CreateDevice(const wgpu::DeviceDescriptor* deviceDescriptor);\n    WGPUDevice CreateDevice(const WGPUDeviceDescriptor* deviceDescriptor = nullptr);\n\n    void RequestDevice(const DawnDeviceDescriptor* descriptor,\n                       WGPURequestDeviceCallback callback,\n                       void* userdata);\n    void RequestDevice(const wgpu::DeviceDescriptor* descriptor,\n                       WGPURequestDeviceCallback callback,\n                       void* userdata);\n    void RequestDevice(const WGPUDeviceDescriptor* descriptor,\n                       WGPURequestDeviceCallback callback,\n                       void* userdata);\n\n    // Returns the underlying WGPUAdapter object.\n    WGPUAdapter Get() const;\n\n    // Reset the backend device object for testing purposes.\n    void ResetInternalDeviceForTesting();\n\n  private:\n    AdapterBase* mImpl = nullptr;\n};\n\n// Base class for options passed to Instance::DiscoverAdapters.\nstruct DAWN_NATIVE_EXPORT AdapterDiscoveryOptionsBase {\n  public:\n    const WGPUBackendType backendType;\n\n  protected:\n    explicit AdapterDiscoveryOptionsBase(WGPUBackendType type);\n};\n\nenum BackendValidationLevel { Full, Partial, Disabled };\n\n// Represents a connection to dawn_native and is used for dependency injection, discovering\n// system adapters and injecting custom adapters (like a Swiftshader Vulkan adapter).\n//\n// This is an RAII class for Dawn instances and also controls the lifetime of all adapters\n// for this instance.\nclass DAWN_NATIVE_EXPORT Instance {\n  public:\n    explicit Instance(const WGPUInstanceDescriptor* desc = nullptr);\n    ~Instance();\n\n    Instance(const Instance& other) = delete;\n    Instance& operator=(const Instance& other) = delete;\n\n    // Gather all adapters in the system that can be accessed with no special options. These\n    // adapters will later be returned by GetAdapters.\n    void DiscoverDefaultAdapters();\n\n    // Adds adapters that can be discovered with the options provided (like a getProcAddress).\n    // The backend is chosen based on the type of the options used. Returns true on success.\n    bool DiscoverAdapters(const AdapterDiscoveryOptionsBase* options);\n\n    // Returns all the adapters that the instance knows about.\n    std::vector<Adapter> GetAdapters() const;\n\n    const ToggleInfo* GetToggleInfo(const char* toggleName);\n    const FeatureInfo* GetFeatureInfo(WGPUFeatureName feature);\n\n    // Enables backend validation layers\n    void EnableBackendValidation(bool enableBackendValidation);\n    void SetBackendValidationLevel(BackendValidationLevel validationLevel);\n\n    // Enable debug capture on Dawn startup\n    void EnableBeginCaptureOnStartup(bool beginCaptureOnStartup);\n\n    // TODO(dawn:1374) Deprecate this once it is passed via the descriptor.\n    void SetPlatform(dawn::platform::Platform* platform);\n\n    uint64_t GetDeviceCountForTesting() const;\n\n    // Returns the underlying WGPUInstance object.\n    WGPUInstance Get() const;\n\n  private:\n    InstanceBase* mImpl = nullptr;\n};\n\n// Backend-agnostic API for dawn_native\nDAWN_NATIVE_EXPORT const DawnProcTable& GetProcs();\n\n// Query the names of all the toggles that are enabled in device\nDAWN_NATIVE_EXPORT std::vector<const char*> GetTogglesUsed(WGPUDevice device);\n\n// Backdoor to get the number of lazy clears for testing\nDAWN_NATIVE_EXPORT size_t GetLazyClearCountForTesting(WGPUDevice device);\n\n// Backdoor to get the number of deprecation warnings for testing\nDAWN_NATIVE_EXPORT size_t GetDeprecationWarningCountForTesting(WGPUDevice device);\n\n// Backdoor to get the number of adapters an instance knows about for testing\nDAWN_NATIVE_EXPORT size_t GetAdapterCountForTesting(WGPUInstance instance);\n\n//  Query if texture has been initialized\nDAWN_NATIVE_EXPORT bool IsTextureSubresourceInitialized(\n    WGPUTexture texture,\n    uint32_t baseMipLevel,\n    uint32_t levelCount,\n    uint32_t baseArrayLayer,\n    uint32_t layerCount,\n    WGPUTextureAspect aspect = WGPUTextureAspect_All);\n\n// Backdoor to get the order of the ProcMap for testing\nDAWN_NATIVE_EXPORT std::vector<const char*> GetProcMapNamesForTesting();\n\nDAWN_NATIVE_EXPORT bool DeviceTick(WGPUDevice device);\n\n// ErrorInjector functions used for testing only. Defined in dawn_native/ErrorInjector.cpp\nDAWN_NATIVE_EXPORT void EnableErrorInjector();\nDAWN_NATIVE_EXPORT void DisableErrorInjector();\nDAWN_NATIVE_EXPORT void ClearErrorInjector();\nDAWN_NATIVE_EXPORT uint64_t AcquireErrorInjectorCallCount();\nDAWN_NATIVE_EXPORT void InjectErrorAt(uint64_t index);\n\n// The different types of external images\nenum ExternalImageType {\n    OpaqueFD,\n    DmaBuf,\n    IOSurface,\n    DXGISharedHandle,\n    EGLImage,\n    AHardwareBuffer,\n};\n\n// Common properties of external images\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptor {\n  public:\n    const WGPUTextureDescriptor* cTextureDescriptor;  // Must match image creation params\n    bool isInitialized;  // Whether the texture is initialized on import\n    ExternalImageType GetType() const;\n\n  protected:\n    explicit ExternalImageDescriptor(ExternalImageType type);\n\n  private:\n    ExternalImageType mType;\n};\n\nstruct DAWN_NATIVE_EXPORT ExternalImageExportInfo {\n  public:\n    bool isInitialized = false;  // Whether the texture is initialized after export\n    ExternalImageType GetType() const;\n\n  protected:\n    explicit ExternalImageExportInfo(ExternalImageType type);\n\n  private:\n    ExternalImageType mType;\n};\n\nDAWN_NATIVE_EXPORT bool CheckIsErrorForTesting(void* objectHandle);\n\nDAWN_NATIVE_EXPORT const char* GetObjectLabelForTesting(void* objectHandle);\n\nDAWN_NATIVE_EXPORT uint64_t GetAllocatedSizeForTesting(WGPUBuffer buffer);\n\nDAWN_NATIVE_EXPORT bool BindGroupLayoutBindingsEqualForTesting(WGPUBindGroupLayout a,\n                                                               WGPUBindGroupLayout b);\n\n}  // namespace dawn::native\n\n// TODO(dawn:824): Remove once the deprecation period is passed.\nnamespace dawn_native = dawn::native;\n\n#endif  // INCLUDE_DAWN_NATIVE_DAWNNATIVE_H_\n", "./include/dawn/native/OpenGLBackend.h": "// Copyright 2018 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_NATIVE_OPENGLBACKEND_H_\n#define INCLUDE_DAWN_NATIVE_OPENGLBACKEND_H_\n\ntypedef void* EGLImage;\n\n#include \"dawn/dawn_wsi.h\"\n#include \"dawn/native/DawnNative.h\"\n\nnamespace dawn::native::opengl {\n\nstruct DAWN_NATIVE_EXPORT AdapterDiscoveryOptions : public AdapterDiscoveryOptionsBase {\n    explicit AdapterDiscoveryOptions(WGPUBackendType type);\n\n    void* (*getProc)(const char*);\n};\n\n// TODO(crbug.com/dawn/810): This struct can be removed once Chrome is no longer using it.\nstruct DAWN_NATIVE_EXPORT AdapterDiscoveryOptionsES : public AdapterDiscoveryOptions {\n    AdapterDiscoveryOptionsES();\n};\n\nusing PresentCallback = void (*)(void*);\nDAWN_NATIVE_EXPORT DawnSwapChainImplementation CreateNativeSwapChainImpl(WGPUDevice device,\n                                                                         PresentCallback present,\n                                                                         void* presentUserdata);\nDAWN_NATIVE_EXPORT WGPUTextureFormat\nGetNativeSwapChainPreferredFormat(const DawnSwapChainImplementation* swapChain);\n\nstruct DAWN_NATIVE_EXPORT ExternalImageDescriptorEGLImage : ExternalImageDescriptor {\n  public:\n    ExternalImageDescriptorEGLImage();\n\n    ::EGLImage image;\n};\n\nDAWN_NATIVE_EXPORT WGPUTexture\nWrapExternalEGLImage(WGPUDevice device, const ExternalImageDescriptorEGLImage* descriptor);\n\n}  // namespace dawn::native::opengl\n\n#endif  // INCLUDE_DAWN_NATIVE_OPENGLBACKEND_H_\n", "./include/dawn/platform/dawn_platform_export.h": "// Copyright 2020 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_PLATFORM_DAWN_PLATFORM_EXPORT_H_\n#define INCLUDE_DAWN_PLATFORM_DAWN_PLATFORM_EXPORT_H_\n\n#if defined(DAWN_PLATFORM_SHARED_LIBRARY)\n#if defined(_WIN32)\n#if defined(DAWN_PLATFORM_IMPLEMENTATION)\n#define DAWN_PLATFORM_EXPORT __declspec(dllexport)\n#else\n#define DAWN_PLATFORM_EXPORT __declspec(dllimport)\n#endif\n#else  // defined(_WIN32)\n#if defined(DAWN_PLATFORM_IMPLEMENTATION)\n#define DAWN_PLATFORM_EXPORT __attribute__((visibility(\"default\")))\n#else\n#define DAWN_PLATFORM_EXPORT\n#endif\n#endif  // defined(_WIN32)\n#else   // defined(DAWN_PLATFORM_SHARED_LIBRARY)\n#define DAWN_PLATFORM_EXPORT\n#endif  // defined(DAWN_PLATFORM_SHARED_LIBRARY)\n\n#endif  // INCLUDE_DAWN_PLATFORM_DAWN_PLATFORM_EXPORT_H_\n", "./include/dawn/platform/DawnPlatform.h": "// Copyright 2019 The Dawn Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef INCLUDE_DAWN_PLATFORM_DAWNPLATFORM_H_\n#define INCLUDE_DAWN_PLATFORM_DAWNPLATFORM_H_\n\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n\n#include \"dawn/platform/dawn_platform_export.h\"\n#include \"dawn/webgpu.h\"\n\nnamespace dawn::platform {\n\nenum class TraceCategory {\n    General,     // General trace events\n    Validation,  // Dawn validation\n    Recording,   // Native command recording\n    GPUWork,     // Actual GPU work\n};\n\nclass DAWN_PLATFORM_EXPORT CachingInterface {\n  public:\n    CachingInterface();\n    virtual ~CachingInterface();\n\n    // LoadData has two modes. The first mode is used to get a value which\n    // corresponds to the |key|. The |valueOut| is a caller provided buffer\n    // allocated to the size |valueSize| which is loaded with data of the\n    // size returned. The second mode is used to query for the existence of\n    // the |key| where |valueOut| is nullptr and |valueSize| must be 0.\n    // The return size is non-zero if the |key| exists.\n    virtual size_t LoadData(const void* key, size_t keySize, void* valueOut, size_t valueSize) = 0;\n\n    // StoreData puts a |value| in the cache which corresponds to the |key|.\n    virtual void StoreData(const void* key,\n                           size_t keySize,\n                           const void* value,\n                           size_t valueSize) = 0;\n\n  private:\n    CachingInterface(const CachingInterface&) = delete;\n    CachingInterface& operator=(const CachingInterface&) = delete;\n};\n\nclass DAWN_PLATFORM_EXPORT WaitableEvent {\n  public:\n    WaitableEvent() = default;\n    virtual ~WaitableEvent() = default;\n    virtual void Wait() = 0;        // Wait for completion\n    virtual bool IsComplete() = 0;  // Non-blocking check if the event is complete\n};\n\nusing PostWorkerTaskCallback = void (*)(void* userdata);\n\nclass DAWN_PLATFORM_EXPORT WorkerTaskPool {\n  public:\n    WorkerTaskPool() = default;\n    virtual ~WorkerTaskPool() = default;\n    virtual std::unique_ptr<WaitableEvent> PostWorkerTask(PostWorkerTaskCallback,\n                                                          void* userdata) = 0;\n};\n\nclass DAWN_PLATFORM_EXPORT Platform {\n  public:\n    Platform();\n    virtual ~Platform();\n\n    virtual const unsigned char* GetTraceCategoryEnabledFlag(TraceCategory category);\n\n    virtual double MonotonicallyIncreasingTime();\n\n    virtual uint64_t AddTraceEvent(char phase,\n                                   const unsigned char* categoryGroupEnabled,\n                                   const char* name,\n                                   uint64_t id,\n                                   double timestamp,\n                                   int numArgs,\n                                   const char** argNames,\n                                   const unsigned char* argTypes,\n                                   const uint64_t* argValues,\n                                   unsigned char flags);\n\n    // The returned CachingInterface is expected to outlive the device which uses it to persistently\n    // cache objects.\n    virtual CachingInterface* GetCachingInterface();\n\n    virtual std::unique_ptr<WorkerTaskPool> CreateWorkerTaskPool();\n\n  private:\n    Platform(const Platform&) = delete;\n    Platform& operator=(const Platform&) = delete;\n};\n\n}  // namespace dawn::platform\n\n// TODO(dawn:824): Remove once the deprecation period is passed.\nnamespace dawn_platform = dawn::platform;\n\n#endif  // INCLUDE_DAWN_PLATFORM_DAWNPLATFORM_H_\n"}
